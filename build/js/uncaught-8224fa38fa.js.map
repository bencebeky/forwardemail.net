{"version":3,"sources":["js/uncaught.js","js/node_modules/factor-bundle/node_modules/browser-pack/_prelude.js","js/assets/js/uncaught.js","js/node_modules/uncaught/lib/index.js","js/node_modules/stacktrace-js/stacktrace.js","js/node_modules/stacktrace-gps/stacktrace-gps.js","js/node_modules/stacktrace-gps/node_modules/source-map/lib/source-map-consumer.js","js/node_modules/stacktrace-gps/node_modules/source-map/lib/quick-sort.js","js/node_modules/stacktrace-gps/node_modules/source-map/lib/binary-search.js","js/node_modules/stacktrace-gps/node_modules/source-map/lib/base64-vlq.js","js/node_modules/stacktrace-gps/node_modules/source-map/lib/base64.js","js/node_modules/stacktrace-gps/node_modules/source-map/lib/array-set.js","js/node_modules/stacktrace-gps/node_modules/source-map/lib/util.js","js/node_modules/stack-generator/stack-generator.js","js/node_modules/error-stack-parser/error-stack-parser.js","js/node_modules/stackframe/stackframe.js","js/node_modules/prepare-stack-trace/src/index.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","require","e","t","n","r","s","o","u","a","i","f","Error","code","l","exports","call","length","3","module","StackTrace","prepareStackTrace","uncaught","logger","start","addListener","err","event","ErrorEvent","error","message","fromError","then","stackframes","stack","err_","123","146","155","2","process","root","factory","this","modules","installedModules","__webpack_require__","moduleId","id","loaded","m","c","p","isBrowser","window","listeners","handlersAreRegistered","handlersAreTurnedOn","browserErrorHandler","callListeners","undefined","browserRejectionHandler","reason","nodeErrorHandler","nodeRejectionHandler","forEach","listener","addEventListener","on","stop","removeEventListener","push","removeListener","index","indexOf","splice","removeAllListeners","flush","define","amd","124","ErrorStackParser","StackGenerator","StackTraceGPS","_options","filter","stackframe","functionName","sourceCache","_generateError","_merge","first","second","target","prop","Object","hasOwnProperty","_isShapedLikeParsableError","_filtered","get","opts","generateArtificially","getSync","parse","backtrace","gps","Promise","resolve","all","map","sf","resolveOriginal","pinpoint","bind","stackFrames","instrument","fn","callback","errback","thisArg","__stacktraceOriginalFn","instrumented","apply","arguments","deinstrument","report","url","errorMsg","requestOptions","reject","req","XMLHttpRequest","onerror","onreadystatechange","readyState","status","responseText","open","setRequestHeader","headers","header","reportPayload","send","JSON","stringify","136","145","96","SourceMap","sourceMap","StackFrame","_xdr","substr","_atob","b64str","atob","_ensureStackFrameIsLegit","TypeError","fileName","lineNumber","columnNumber","sourceMapConsumerCache","ajax","_get","location","isDataUrl","offline","match","sourceMapStart","encodedSource","source","xhrPromise","method","_getSourceMapConsumer","sourceMappingURL","defaultSourceRoot","sourceMapConsumerPromise","sourceMapSource","string","_parseJson","replace","sourceRoot","SourceMapConsumer","getMappedLocation","mappedStackFrame","resolveMappedStackFrame","findFunctionName","guessedFunctionName","syntaxes","lines","split","maxLines","Math","min","line","commentPos","len","exec","_findFunctionName","args","defineProperty","create","_ensureSupportedEnvironment","lastSourceMappingUrl","matchSourceMappingUrl","sourceMappingUrlRegExp","_findSourceMappingURL","substring","lastIndexOf","test","sourceMapConsumer","loc","originalPositionFor","column","mappedSource","sourceContentFor","name","_extractLocationInfoFromSourceMapSource","137","143","util","binarySearch","ArraySet","base64VLQ","quickSort","aSourceMap","sections","IndexedSourceMapConsumer","BasicSourceMapConsumer","version","getArg","sources","names","sourcesContent","mappings","file","_version","String","normalize","isAbsolute","relative","_names","fromArray","_sources","_mappings","Mapping","generatedLine","generatedColumn","originalLine","originalColumn","lastOffset","_sections","offset","offsetLine","offsetColumn","generatedOffset","consumer","fromSourceMap","__generatedMappings","_parseMappings","__originalMappings","_charIsMappingSeparator","aStr","charAt","aSourceRoot","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","eachMapping","aCallback","aContext","aOrder","context","_generatedMappings","_originalMappings","mapping","at","join","allGeneratedPositionsFor","aArgs","needle","has","_findMapping","compareByOriginalPositions","lastColumn","smc","toArray","_sourceRoot","_generateSourcesContent","_file","generatedMappings","slice","destGeneratedMappings","destOriginalMappings","srcMapping","destMapping","str","segment","end","value","previousGeneratedColumn","previousOriginalLine","previousOriginalColumn","previousSource","previousName","cachedSegments","temp","originalMappings","decode","rest","compareByGeneratedPositionsDeflated","aNeedle","aMappings","aLineName","aColumnName","aComparator","aBias","search","computeColumnSpans","nextMapping","lastGeneratedColumn","Infinity","hasContentsOfAllSources","size","some","sc","aSource","nullOnMissing","urlParse","fileUriAbsPath","scheme","path","generatedPositionFor","j","sectionIndex","section","cmp","bias","every","content","generatedPosition","sectionMappings","add","adjustedMapping","138","139","141","142","144","swap","ary","x","y","doQuickSort","comparator","low","high","round","random","pivot","q","aHaystack","aCompare","recursiveSearch","aLow","aHigh","mid","floor","base64","encode","aValue","digit","encoded","vlq","toVLQSigned","VLQ_BASE","aIndex","aOutParam","continuation","shifted","strLen","result","shift","charCodeAt","140","intToCharMap","number","charCode","_array","_set","aArray","aAllowDuplicates","set","getOwnPropertyNames","sStr","toSetString","isDuplicate","idx","aIdx","aName","aDefaultValue","urlRegexp","dataUrlRegexp","aUrl","auth","host","port","urlGenerate","aParsedUrl","aPath","part","parts","up","aRoot","aPathUrl","aRootUrl","joined","level","Array","supportsNullProto","identity","isProtoString","strcmp","aStr1","aStr2","fromSetString","mappingA","mappingB","onlyCompareOriginal","onlyCompareGenerated","compareByGeneratedPositionsInflated","maxStackSize","curr","callee","toString","RegExp","$1","caller","FIREFOX_SAFARI_STACK_REGEXP","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","stacktrace","parseOpera","parseV8OrIE","parseFFOrSafari","extractLocation","urlLike","sanitizedLine","tokens","locationParts","pop","functionNameRegex","matches","parseOpera9","parseOpera11","parseOpera10","lineRE","argsRaw","functionCall","_capitalize","toUpperCase","_getter","booleanProps","numericProps","stringProps","props","concat","getArgs","setArgs","v","getEvalOrigin","evalOrigin","setEvalOrigin","getFileName","getLineNumber","getColumnNumber","getFunctionName","getIsEval","fromString","argsStartIndex","argsEndIndex","locationString","Boolean","isNaN","parseFloat","isFinite","Number","k","ErrorToString","trace","errorString"],"mappings":"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","file":"uncaught.js","sourcesContent":["require = function e(t, n, r) {\n    function s(o, u) {\n        if (!n[o]) {\n            if (!t[o]) {\n                var a = typeof require == 'function' && require;\n                if (!u && a)\n                    return a(o, !0);\n                if (i)\n                    return i(o, !0);\n                var f = new Error('Cannot find module \\'' + o + '\\'');\n                throw f.code = 'MODULE_NOT_FOUND', f;\n            }\n            var l = n[o] = { exports: {} };\n            t[o][0].call(l.exports, function (e) {\n                var n = t[o][1][e];\n                return s(n ? n : e);\n            }, l, l.exports, e, t, n, r);\n        }\n        return n[o].exports;\n    }\n    var i = typeof require == 'function' && require;\n    for (var o = 0; o < r.length; o++)\n        s(r[o]);\n    return s;\n}({\n    3: [\n        function (require, module, exports) {\n            const StackTrace = require(146);\n            const prepareStackTrace = require(123);\n            const uncaught = require(155);\n            const logger = require(2);\n            uncaught.start();\n            uncaught.addListener(function (err, event) {\n                if (!err) {\n                    if (typeof ErrorEvent === 'function' && event instanceof ErrorEvent)\n                        return logger.error(event.message, { event });\n                    logger.error({ event });\n                    return;\n                }\n                StackTrace.fromError(err).then(stackframes => {\n                    err.stack = prepareStackTrace(err, stackframes);\n                    logger.error(err);\n                }).catch(err_ => {\n                    logger.error(err);\n                    logger.error(err_);\n                });\n            });\n            module.exports = uncaught;\n        },\n        {\n            '123': 123,\n            '146': 146,\n            '155': 155,\n            '2': 2\n        }\n    ],\n    155: [\n        function (require, module, exports) {\n            (function (process) {\n                (function webpackUniversalModuleDefinition(root, factory) {\n                    if (typeof exports === 'object' && typeof module === 'object')\n                        module.exports = factory();\n                    else if (typeof define === 'function' && define.amd)\n                        define([], factory);\n                    else if (typeof exports === 'object')\n                        exports['uncaught'] = factory();\n                    else\n                        root['uncaught'] = factory();\n                }(this, function () {\n                    return function (modules) {\n                        var installedModules = {};\n                        function __webpack_require__(moduleId) {\n                            if (installedModules[moduleId])\n                                return installedModules[moduleId].exports;\n                            var module = installedModules[moduleId] = {\n                                exports: {},\n                                id: moduleId,\n                                loaded: false\n                            };\n                            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n                            module.loaded = true;\n                            return module.exports;\n                        }\n                        __webpack_require__.m = modules;\n                        __webpack_require__.c = installedModules;\n                        __webpack_require__.p = '';\n                        return __webpack_require__(0);\n                    }([function (module, exports) {\n                            'use strict';\n                            var isBrowser = typeof window !== 'undefined';\n                            var listeners = [];\n                            var handlersAreRegistered = false;\n                            var handlersAreTurnedOn = false;\n                            module.exports = {\n                                start: function start() {\n                                    if (handlersAreTurnedOn) {\n                                        return;\n                                    }\n                                    if (!handlersAreRegistered) {\n                                        if (isBrowser) {\n                                            window.addEventListener('error', browserErrorHandler);\n                                            window.addEventListener('unhandledrejection', browserRejectionHandler);\n                                        } else {\n                                            process.on('uncaughtException', nodeErrorHandler);\n                                            process.on('unhandledRejection', nodeRejectionHandler);\n                                        }\n                                        handlersAreRegistered = true;\n                                    }\n                                    handlersAreTurnedOn = true;\n                                },\n                                stop: function stop() {\n                                    if (!handlersAreTurnedOn) {\n                                        return;\n                                    }\n                                    if (isBrowser) {\n                                        window.removeEventListener('error', browserErrorHandler);\n                                        window.removeEventListener('unhandledrejection', browserRejectionHandler);\n                                        handlersAreRegistered = false;\n                                    }\n                                    handlersAreTurnedOn = false;\n                                },\n                                addListener: function addListener(listener) {\n                                    if (typeof listener === 'function') {\n                                        listeners.push(listener);\n                                    }\n                                },\n                                removeListener: function removeListener(listener) {\n                                    var index = listeners.indexOf(listener);\n                                    if (index > -1) {\n                                        listeners.splice(index, 1);\n                                    }\n                                },\n                                removeAllListeners: function removeAllListeners() {\n                                    listeners.length = 0;\n                                },\n                                flush: function flush() {\n                                    this.removeAllListeners();\n                                    this.stop();\n                                }\n                            };\n                            function browserErrorHandler(event) {\n                                var error = event ? event.error : undefined;\n                                callListeners(error, event);\n                            }\n                            function browserRejectionHandler(event) {\n                                var error = event ? event.reason : undefined;\n                                callListeners(error, event);\n                            }\n                            function nodeErrorHandler(error) {\n                                if (handlersAreTurnedOn) {\n                                    callListeners(error, null);\n                                }\n                            }\n                            function nodeRejectionHandler(reason) {\n                                if (handlersAreTurnedOn) {\n                                    callListeners(reason, null);\n                                }\n                            }\n                            function callListeners(error, event) {\n                                listeners.forEach(function (listener) {\n                                    listener(error, event);\n                                });\n                            }\n                        }]);\n                }));\n                ;\n            }.call(this, require(124)));\n        },\n        { '124': 124 }\n    ],\n    146: [\n        function (require, module, exports) {\n            (function (root, factory) {\n                'use strict';\n                if (typeof define === 'function' && define.amd) {\n                    define('stacktrace', [\n                        'error-stack-parser',\n                        'stack-generator',\n                        'stacktrace-gps'\n                    ], factory);\n                } else if (typeof exports === 'object') {\n                    module.exports = factory(require(96), require(136), require(145));\n                } else {\n                    root.StackTrace = factory(root.ErrorStackParser, root.StackGenerator, root.StackTraceGPS);\n                }\n            }(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {\n                var _options = {\n                    filter: function (stackframe) {\n                        return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 && (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 && (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 && (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;\n                    },\n                    sourceCache: {}\n                };\n                var _generateError = function StackTrace$$GenerateError() {\n                    try {\n                        throw new Error();\n                    } catch (err) {\n                        return err;\n                    }\n                };\n                function _merge(first, second) {\n                    var target = {};\n                    [\n                        first,\n                        second\n                    ].forEach(function (obj) {\n                        for (var prop in obj) {\n                            if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n                                target[prop] = obj[prop];\n                            }\n                        }\n                        return target;\n                    });\n                    return target;\n                }\n                function _isShapedLikeParsableError(err) {\n                    return err.stack || err['opera#sourceloc'];\n                }\n                function _filtered(stackframes, filter) {\n                    if (typeof filter === 'function') {\n                        return stackframes.filter(filter);\n                    }\n                    return stackframes;\n                }\n                return {\n                    get: function StackTrace$$get(opts) {\n                        var err = _generateError();\n                        return _isShapedLikeParsableError(err) ? this.fromError(err, opts) : this.generateArtificially(opts);\n                    },\n                    getSync: function StackTrace$$getSync(opts) {\n                        opts = _merge(_options, opts);\n                        var err = _generateError();\n                        var stack = _isShapedLikeParsableError(err) ? ErrorStackParser.parse(err) : StackGenerator.backtrace(opts);\n                        return _filtered(stack, opts.filter);\n                    },\n                    fromError: function StackTrace$$fromError(error, opts) {\n                        opts = _merge(_options, opts);\n                        var gps = new StackTraceGPS(opts);\n                        return new Promise(function (resolve) {\n                            var stackframes = _filtered(ErrorStackParser.parse(error), opts.filter);\n                            resolve(Promise.all(stackframes.map(function (sf) {\n                                return new Promise(function (resolve) {\n                                    function resolveOriginal() {\n                                        resolve(sf);\n                                    }\n                                    gps.pinpoint(sf).then(resolve, resolveOriginal)['catch'](resolveOriginal);\n                                });\n                            })));\n                        }.bind(this));\n                    },\n                    generateArtificially: function StackTrace$$generateArtificially(opts) {\n                        opts = _merge(_options, opts);\n                        var stackFrames = StackGenerator.backtrace(opts);\n                        if (typeof opts.filter === 'function') {\n                            stackFrames = stackFrames.filter(opts.filter);\n                        }\n                        return Promise.resolve(stackFrames);\n                    },\n                    instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {\n                        if (typeof fn !== 'function') {\n                            throw new Error('Cannot instrument non-function object');\n                        } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n                            return fn;\n                        }\n                        var instrumented = function StackTrace$$instrumented() {\n                            try {\n                                this.get().then(callback, errback)['catch'](errback);\n                                return fn.apply(thisArg || this, arguments);\n                            } catch (e) {\n                                if (_isShapedLikeParsableError(e)) {\n                                    this.fromError(e).then(callback, errback)['catch'](errback);\n                                }\n                                throw e;\n                            }\n                        }.bind(this);\n                        instrumented.__stacktraceOriginalFn = fn;\n                        return instrumented;\n                    },\n                    deinstrument: function StackTrace$$deinstrument(fn) {\n                        if (typeof fn !== 'function') {\n                            throw new Error('Cannot de-instrument non-function object');\n                        } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n                            return fn.__stacktraceOriginalFn;\n                        } else {\n                            return fn;\n                        }\n                    },\n                    report: function StackTrace$$report(stackframes, url, errorMsg, requestOptions) {\n                        return new Promise(function (resolve, reject) {\n                            var req = new XMLHttpRequest();\n                            req.onerror = reject;\n                            req.onreadystatechange = function onreadystatechange() {\n                                if (req.readyState === 4) {\n                                    if (req.status >= 200 && req.status < 400) {\n                                        resolve(req.responseText);\n                                    } else {\n                                        reject(new Error('POST to ' + url + ' failed with status: ' + req.status));\n                                    }\n                                }\n                            };\n                            req.open('post', url);\n                            req.setRequestHeader('Content-Type', 'application/json');\n                            if (requestOptions && typeof requestOptions.headers === 'object') {\n                                var headers = requestOptions.headers;\n                                for (var header in headers) {\n                                    if (Object.prototype.hasOwnProperty.call(headers, header)) {\n                                        req.setRequestHeader(header, headers[header]);\n                                    }\n                                }\n                            }\n                            var reportPayload = { stack: stackframes };\n                            if (errorMsg !== undefined && errorMsg !== null) {\n                                reportPayload.message = errorMsg;\n                            }\n                            req.send(JSON.stringify(reportPayload));\n                        });\n                    }\n                };\n            }));\n        },\n        {\n            '136': 136,\n            '145': 145,\n            '96': 96\n        }\n    ],\n    145: [\n        function (require, module, exports) {\n            (function (root, factory) {\n                'use strict';\n                if (typeof define === 'function' && define.amd) {\n                    define('stacktrace-gps', [\n                        'source-map',\n                        'stackframe'\n                    ], factory);\n                } else if (typeof exports === 'object') {\n                    module.exports = factory(require(143), require(137));\n                } else {\n                    root.StackTraceGPS = factory(root.SourceMap || root.sourceMap, root.StackFrame);\n                }\n            }(this, function (SourceMap, StackFrame) {\n                'use strict';\n                function _xdr(url) {\n                    return new Promise(function (resolve, reject) {\n                        var req = new XMLHttpRequest();\n                        req.open('get', url);\n                        req.onerror = reject;\n                        req.onreadystatechange = function onreadystatechange() {\n                            if (req.readyState === 4) {\n                                if (req.status >= 200 && req.status < 300 || url.substr(0, 7) === 'file://' && req.responseText) {\n                                    resolve(req.responseText);\n                                } else {\n                                    reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));\n                                }\n                            }\n                        };\n                        req.send();\n                    });\n                }\n                function _atob(b64str) {\n                    if (typeof window !== 'undefined' && window.atob) {\n                        return window.atob(b64str);\n                    } else {\n                        throw new Error('You must supply a polyfill for window.atob in this environment');\n                    }\n                }\n                function _parseJson(string) {\n                    if (typeof JSON !== 'undefined' && JSON.parse) {\n                        return JSON.parse(string);\n                    } else {\n                        throw new Error('You must supply a polyfill for JSON.parse in this environment');\n                    }\n                }\n                function _findFunctionName(source, lineNumber) {\n                    var syntaxes = [\n                        /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/,\n                        /function\\s+([^('\"`]*?)\\s*\\(([^)]*)\\)/,\n                        /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/,\n                        /\\b(?!(?:if|for|switch|while|with|catch)\\b)(?:(?:static)\\s+)?(\\S+)\\s*\\(.*?\\)\\s*\\{/,\n                        /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*\\(.*?\\)\\s*=>/\n                    ];\n                    var lines = source.split('\\n');\n                    var code = '';\n                    var maxLines = Math.min(lineNumber, 20);\n                    for (var i = 0; i < maxLines; ++i) {\n                        var line = lines[lineNumber - i - 1];\n                        var commentPos = line.indexOf('//');\n                        if (commentPos >= 0) {\n                            line = line.substr(0, commentPos);\n                        }\n                        if (line) {\n                            code = line + code;\n                            var len = syntaxes.length;\n                            for (var index = 0; index < len; index++) {\n                                var m = syntaxes[index].exec(code);\n                                if (m && m[1]) {\n                                    return m[1];\n                                }\n                            }\n                        }\n                    }\n                    return undefined;\n                }\n                function _ensureSupportedEnvironment() {\n                    if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {\n                        throw new Error('Unable to consume source maps in older browsers');\n                    }\n                }\n                function _ensureStackFrameIsLegit(stackframe) {\n                    if (typeof stackframe !== 'object') {\n                        throw new TypeError('Given StackFrame is not an object');\n                    } else if (typeof stackframe.fileName !== 'string') {\n                        throw new TypeError('Given file name is not a String');\n                    } else if (typeof stackframe.lineNumber !== 'number' || stackframe.lineNumber % 1 !== 0 || stackframe.lineNumber < 1) {\n                        throw new TypeError('Given line number must be a positive integer');\n                    } else if (typeof stackframe.columnNumber !== 'number' || stackframe.columnNumber % 1 !== 0 || stackframe.columnNumber < 0) {\n                        throw new TypeError('Given column number must be a non-negative integer');\n                    }\n                    return true;\n                }\n                function _findSourceMappingURL(source) {\n                    var sourceMappingUrlRegExp = /\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)\\s*$/mg;\n                    var lastSourceMappingUrl;\n                    var matchSourceMappingUrl;\n                    while (matchSourceMappingUrl = sourceMappingUrlRegExp.exec(source)) {\n                        lastSourceMappingUrl = matchSourceMappingUrl[1];\n                    }\n                    if (lastSourceMappingUrl) {\n                        return lastSourceMappingUrl;\n                    } else {\n                        throw new Error('sourceMappingURL not found');\n                    }\n                }\n                function _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache) {\n                    return new Promise(function (resolve, reject) {\n                        var loc = sourceMapConsumer.originalPositionFor({\n                            line: stackframe.lineNumber,\n                            column: stackframe.columnNumber\n                        });\n                        if (loc.source) {\n                            var mappedSource = sourceMapConsumer.sourceContentFor(loc.source);\n                            if (mappedSource) {\n                                sourceCache[loc.source] = mappedSource;\n                            }\n                            resolve(new StackFrame({\n                                functionName: loc.name || stackframe.functionName,\n                                args: stackframe.args,\n                                fileName: loc.source,\n                                lineNumber: loc.line,\n                                columnNumber: loc.column\n                            }));\n                        } else {\n                            reject(new Error('Could not get original source for given stackframe and source map'));\n                        }\n                    });\n                }\n                return function StackTraceGPS(opts) {\n                    if (!(this instanceof StackTraceGPS)) {\n                        return new StackTraceGPS(opts);\n                    }\n                    opts = opts || {};\n                    this.sourceCache = opts.sourceCache || {};\n                    this.sourceMapConsumerCache = opts.sourceMapConsumerCache || {};\n                    this.ajax = opts.ajax || _xdr;\n                    this._atob = opts.atob || _atob;\n                    this._get = function _get(location) {\n                        return new Promise(function (resolve, reject) {\n                            var isDataUrl = location.substr(0, 5) === 'data:';\n                            if (this.sourceCache[location]) {\n                                resolve(this.sourceCache[location]);\n                            } else if (opts.offline && !isDataUrl) {\n                                reject(new Error('Cannot make network requests in offline mode'));\n                            } else {\n                                if (isDataUrl) {\n                                    var supportedEncodingRegexp = /^data:application\\/json;([\\w=:\"-]+;)*base64,/;\n                                    var match = location.match(supportedEncodingRegexp);\n                                    if (match) {\n                                        var sourceMapStart = match[0].length;\n                                        var encodedSource = location.substr(sourceMapStart);\n                                        var source = this._atob(encodedSource);\n                                        this.sourceCache[location] = source;\n                                        resolve(source);\n                                    } else {\n                                        reject(new Error('The encoding of the inline sourcemap is not supported'));\n                                    }\n                                } else {\n                                    var xhrPromise = this.ajax(location, { method: 'get' });\n                                    this.sourceCache[location] = xhrPromise;\n                                    xhrPromise.then(resolve, reject);\n                                }\n                            }\n                        }.bind(this));\n                    };\n                    this._getSourceMapConsumer = function _getSourceMapConsumer(sourceMappingURL, defaultSourceRoot) {\n                        return new Promise(function (resolve) {\n                            if (this.sourceMapConsumerCache[sourceMappingURL]) {\n                                resolve(this.sourceMapConsumerCache[sourceMappingURL]);\n                            } else {\n                                var sourceMapConsumerPromise = new Promise(function (resolve, reject) {\n                                    return this._get(sourceMappingURL).then(function (sourceMapSource) {\n                                        if (typeof sourceMapSource === 'string') {\n                                            sourceMapSource = _parseJson(sourceMapSource.replace(/^\\)\\]\\}'/, ''));\n                                        }\n                                        if (typeof sourceMapSource.sourceRoot === 'undefined') {\n                                            sourceMapSource.sourceRoot = defaultSourceRoot;\n                                        }\n                                        resolve(new SourceMap.SourceMapConsumer(sourceMapSource));\n                                    }, reject);\n                                }.bind(this));\n                                this.sourceMapConsumerCache[sourceMappingURL] = sourceMapConsumerPromise;\n                                resolve(sourceMapConsumerPromise);\n                            }\n                        }.bind(this));\n                    };\n                    this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {\n                        return new Promise(function (resolve, reject) {\n                            this.getMappedLocation(stackframe).then(function (mappedStackFrame) {\n                                function resolveMappedStackFrame() {\n                                    resolve(mappedStackFrame);\n                                }\n                                this.findFunctionName(mappedStackFrame).then(resolve, resolveMappedStackFrame)['catch'](resolveMappedStackFrame);\n                            }.bind(this), reject);\n                        }.bind(this));\n                    };\n                    this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {\n                        return new Promise(function (resolve, reject) {\n                            _ensureStackFrameIsLegit(stackframe);\n                            this._get(stackframe.fileName).then(function getSourceCallback(source) {\n                                var lineNumber = stackframe.lineNumber;\n                                var columnNumber = stackframe.columnNumber;\n                                var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);\n                                if (guessedFunctionName) {\n                                    resolve(new StackFrame({\n                                        functionName: guessedFunctionName,\n                                        args: stackframe.args,\n                                        fileName: stackframe.fileName,\n                                        lineNumber: lineNumber,\n                                        columnNumber: columnNumber\n                                    }));\n                                } else {\n                                    resolve(stackframe);\n                                }\n                            }, reject)['catch'](reject);\n                        }.bind(this));\n                    };\n                    this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {\n                        return new Promise(function (resolve, reject) {\n                            _ensureSupportedEnvironment();\n                            _ensureStackFrameIsLegit(stackframe);\n                            var sourceCache = this.sourceCache;\n                            var fileName = stackframe.fileName;\n                            this._get(fileName).then(function (source) {\n                                var sourceMappingURL = _findSourceMappingURL(source);\n                                var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';\n                                var defaultSourceRoot = fileName.substring(0, fileName.lastIndexOf('/') + 1);\n                                if (sourceMappingURL[0] !== '/' && !isDataUrl && !/^https?:\\/\\/|^\\/\\//i.test(sourceMappingURL)) {\n                                    sourceMappingURL = defaultSourceRoot + sourceMappingURL;\n                                }\n                                return this._getSourceMapConsumer(sourceMappingURL, defaultSourceRoot).then(function (sourceMapConsumer) {\n                                    return _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache).then(resolve)['catch'](function () {\n                                        resolve(stackframe);\n                                    });\n                                });\n                            }.bind(this), reject)['catch'](reject);\n                        }.bind(this));\n                    };\n                };\n            }));\n        },\n        {\n            '137': 137,\n            '143': 143\n        }\n    ],\n    143: [\n        function (require, module, exports) {\n            var util = require(144);\n            var binarySearch = require(141);\n            var ArraySet = require(138).ArraySet;\n            var base64VLQ = require(139);\n            var quickSort = require(142).quickSort;\n            function SourceMapConsumer(aSourceMap) {\n                var sourceMap = aSourceMap;\n                if (typeof aSourceMap === 'string') {\n                    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n                }\n                return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);\n            }\n            SourceMapConsumer.fromSourceMap = function (aSourceMap) {\n                return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n            };\n            SourceMapConsumer.prototype._version = 3;\n            SourceMapConsumer.prototype.__generatedMappings = null;\n            Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n                get: function () {\n                    if (!this.__generatedMappings) {\n                        this._parseMappings(this._mappings, this.sourceRoot);\n                    }\n                    return this.__generatedMappings;\n                }\n            });\n            SourceMapConsumer.prototype.__originalMappings = null;\n            Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n                get: function () {\n                    if (!this.__originalMappings) {\n                        this._parseMappings(this._mappings, this.sourceRoot);\n                    }\n                    return this.__originalMappings;\n                }\n            });\n            SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n                var c = aStr.charAt(index);\n                return c === ';' || c === ',';\n            };\n            SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n                throw new Error('Subclasses must implement _parseMappings');\n            };\n            SourceMapConsumer.GENERATED_ORDER = 1;\n            SourceMapConsumer.ORIGINAL_ORDER = 2;\n            SourceMapConsumer.GREATEST_LOWER_BOUND = 1;\n            SourceMapConsumer.LEAST_UPPER_BOUND = 2;\n            SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n                var context = aContext || null;\n                var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n                var mappings;\n                switch (order) {\n                case SourceMapConsumer.GENERATED_ORDER:\n                    mappings = this._generatedMappings;\n                    break;\n                case SourceMapConsumer.ORIGINAL_ORDER:\n                    mappings = this._originalMappings;\n                    break;\n                default:\n                    throw new Error('Unknown order of iteration.');\n                }\n                var sourceRoot = this.sourceRoot;\n                mappings.map(function (mapping) {\n                    var source = mapping.source === null ? null : this._sources.at(mapping.source);\n                    if (source != null && sourceRoot != null) {\n                        source = util.join(sourceRoot, source);\n                    }\n                    return {\n                        source: source,\n                        generatedLine: mapping.generatedLine,\n                        generatedColumn: mapping.generatedColumn,\n                        originalLine: mapping.originalLine,\n                        originalColumn: mapping.originalColumn,\n                        name: mapping.name === null ? null : this._names.at(mapping.name)\n                    };\n                }, this).forEach(aCallback, context);\n            };\n            SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n                var line = util.getArg(aArgs, 'line');\n                var needle = {\n                    source: util.getArg(aArgs, 'source'),\n                    originalLine: line,\n                    originalColumn: util.getArg(aArgs, 'column', 0)\n                };\n                if (this.sourceRoot != null) {\n                    needle.source = util.relative(this.sourceRoot, needle.source);\n                }\n                if (!this._sources.has(needle.source)) {\n                    return [];\n                }\n                needle.source = this._sources.indexOf(needle.source);\n                var mappings = [];\n                var index = this._findMapping(needle, this._originalMappings, 'originalLine', 'originalColumn', util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);\n                if (index >= 0) {\n                    var mapping = this._originalMappings[index];\n                    if (aArgs.column === undefined) {\n                        var originalLine = mapping.originalLine;\n                        while (mapping && mapping.originalLine === originalLine) {\n                            mappings.push({\n                                line: util.getArg(mapping, 'generatedLine', null),\n                                column: util.getArg(mapping, 'generatedColumn', null),\n                                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n                            });\n                            mapping = this._originalMappings[++index];\n                        }\n                    } else {\n                        var originalColumn = mapping.originalColumn;\n                        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {\n                            mappings.push({\n                                line: util.getArg(mapping, 'generatedLine', null),\n                                column: util.getArg(mapping, 'generatedColumn', null),\n                                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n                            });\n                            mapping = this._originalMappings[++index];\n                        }\n                    }\n                }\n                return mappings;\n            };\n            exports.SourceMapConsumer = SourceMapConsumer;\n            function BasicSourceMapConsumer(aSourceMap) {\n                var sourceMap = aSourceMap;\n                if (typeof aSourceMap === 'string') {\n                    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n                }\n                var version = util.getArg(sourceMap, 'version');\n                var sources = util.getArg(sourceMap, 'sources');\n                var names = util.getArg(sourceMap, 'names', []);\n                var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n                var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n                var mappings = util.getArg(sourceMap, 'mappings');\n                var file = util.getArg(sourceMap, 'file', null);\n                if (version != this._version) {\n                    throw new Error('Unsupported version: ' + version);\n                }\n                sources = sources.map(String).map(util.normalize).map(function (source) {\n                    return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;\n                });\n                this._names = ArraySet.fromArray(names.map(String), true);\n                this._sources = ArraySet.fromArray(sources, true);\n                this.sourceRoot = sourceRoot;\n                this.sourcesContent = sourcesContent;\n                this._mappings = mappings;\n                this.file = file;\n            }\n            BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n            BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n            BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {\n                var smc = Object.create(BasicSourceMapConsumer.prototype);\n                var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n                var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n                smc.sourceRoot = aSourceMap._sourceRoot;\n                smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);\n                smc.file = aSourceMap._file;\n                var generatedMappings = aSourceMap._mappings.toArray().slice();\n                var destGeneratedMappings = smc.__generatedMappings = [];\n                var destOriginalMappings = smc.__originalMappings = [];\n                for (var i = 0, length = generatedMappings.length; i < length; i++) {\n                    var srcMapping = generatedMappings[i];\n                    var destMapping = new Mapping();\n                    destMapping.generatedLine = srcMapping.generatedLine;\n                    destMapping.generatedColumn = srcMapping.generatedColumn;\n                    if (srcMapping.source) {\n                        destMapping.source = sources.indexOf(srcMapping.source);\n                        destMapping.originalLine = srcMapping.originalLine;\n                        destMapping.originalColumn = srcMapping.originalColumn;\n                        if (srcMapping.name) {\n                            destMapping.name = names.indexOf(srcMapping.name);\n                        }\n                        destOriginalMappings.push(destMapping);\n                    }\n                    destGeneratedMappings.push(destMapping);\n                }\n                quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n                return smc;\n            };\n            BasicSourceMapConsumer.prototype._version = 3;\n            Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n                get: function () {\n                    return this._sources.toArray().map(function (s) {\n                        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n                    }, this);\n                }\n            });\n            function Mapping() {\n                this.generatedLine = 0;\n                this.generatedColumn = 0;\n                this.source = null;\n                this.originalLine = null;\n                this.originalColumn = null;\n                this.name = null;\n            }\n            BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n                var generatedLine = 1;\n                var previousGeneratedColumn = 0;\n                var previousOriginalLine = 0;\n                var previousOriginalColumn = 0;\n                var previousSource = 0;\n                var previousName = 0;\n                var length = aStr.length;\n                var index = 0;\n                var cachedSegments = {};\n                var temp = {};\n                var originalMappings = [];\n                var generatedMappings = [];\n                var mapping, str, segment, end, value;\n                while (index < length) {\n                    if (aStr.charAt(index) === ';') {\n                        generatedLine++;\n                        index++;\n                        previousGeneratedColumn = 0;\n                    } else if (aStr.charAt(index) === ',') {\n                        index++;\n                    } else {\n                        mapping = new Mapping();\n                        mapping.generatedLine = generatedLine;\n                        for (end = index; end < length; end++) {\n                            if (this._charIsMappingSeparator(aStr, end)) {\n                                break;\n                            }\n                        }\n                        str = aStr.slice(index, end);\n                        segment = cachedSegments[str];\n                        if (segment) {\n                            index += str.length;\n                        } else {\n                            segment = [];\n                            while (index < end) {\n                                base64VLQ.decode(aStr, index, temp);\n                                value = temp.value;\n                                index = temp.rest;\n                                segment.push(value);\n                            }\n                            if (segment.length === 2) {\n                                throw new Error('Found a source, but no line and column');\n                            }\n                            if (segment.length === 3) {\n                                throw new Error('Found a source and line, but no column');\n                            }\n                            cachedSegments[str] = segment;\n                        }\n                        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n                        previousGeneratedColumn = mapping.generatedColumn;\n                        if (segment.length > 1) {\n                            mapping.source = previousSource + segment[1];\n                            previousSource += segment[1];\n                            mapping.originalLine = previousOriginalLine + segment[2];\n                            previousOriginalLine = mapping.originalLine;\n                            mapping.originalLine += 1;\n                            mapping.originalColumn = previousOriginalColumn + segment[3];\n                            previousOriginalColumn = mapping.originalColumn;\n                            if (segment.length > 4) {\n                                mapping.name = previousName + segment[4];\n                                previousName += segment[4];\n                            }\n                        }\n                        generatedMappings.push(mapping);\n                        if (typeof mapping.originalLine === 'number') {\n                            originalMappings.push(mapping);\n                        }\n                    }\n                }\n                quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n                this.__generatedMappings = generatedMappings;\n                quickSort(originalMappings, util.compareByOriginalPositions);\n                this.__originalMappings = originalMappings;\n            };\n            BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {\n                if (aNeedle[aLineName] <= 0) {\n                    throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);\n                }\n                if (aNeedle[aColumnName] < 0) {\n                    throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);\n                }\n                return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n            };\n            BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {\n                for (var index = 0; index < this._generatedMappings.length; ++index) {\n                    var mapping = this._generatedMappings[index];\n                    if (index + 1 < this._generatedMappings.length) {\n                        var nextMapping = this._generatedMappings[index + 1];\n                        if (mapping.generatedLine === nextMapping.generatedLine) {\n                            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n                            continue;\n                        }\n                    }\n                    mapping.lastGeneratedColumn = Infinity;\n                }\n            };\n            BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {\n                var needle = {\n                    generatedLine: util.getArg(aArgs, 'line'),\n                    generatedColumn: util.getArg(aArgs, 'column')\n                };\n                var index = this._findMapping(needle, this._generatedMappings, 'generatedLine', 'generatedColumn', util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n                if (index >= 0) {\n                    var mapping = this._generatedMappings[index];\n                    if (mapping.generatedLine === needle.generatedLine) {\n                        var source = util.getArg(mapping, 'source', null);\n                        if (source !== null) {\n                            source = this._sources.at(source);\n                            if (this.sourceRoot != null) {\n                                source = util.join(this.sourceRoot, source);\n                            }\n                        }\n                        var name = util.getArg(mapping, 'name', null);\n                        if (name !== null) {\n                            name = this._names.at(name);\n                        }\n                        return {\n                            source: source,\n                            line: util.getArg(mapping, 'originalLine', null),\n                            column: util.getArg(mapping, 'originalColumn', null),\n                            name: name\n                        };\n                    }\n                }\n                return {\n                    source: null,\n                    line: null,\n                    column: null,\n                    name: null\n                };\n            };\n            BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {\n                if (!this.sourcesContent) {\n                    return false;\n                }\n                return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {\n                    return sc == null;\n                });\n            };\n            BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n                if (!this.sourcesContent) {\n                    return null;\n                }\n                if (this.sourceRoot != null) {\n                    aSource = util.relative(this.sourceRoot, aSource);\n                }\n                if (this._sources.has(aSource)) {\n                    return this.sourcesContent[this._sources.indexOf(aSource)];\n                }\n                var url;\n                if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n                    var fileUriAbsPath = aSource.replace(/^file:\\/\\//, '');\n                    if (url.scheme == 'file' && this._sources.has(fileUriAbsPath)) {\n                        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n                    }\n                    if ((!url.path || url.path == '/') && this._sources.has('/' + aSource)) {\n                        return this.sourcesContent[this._sources.indexOf('/' + aSource)];\n                    }\n                }\n                if (nullOnMissing) {\n                    return null;\n                } else {\n                    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n                }\n            };\n            BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {\n                var source = util.getArg(aArgs, 'source');\n                if (this.sourceRoot != null) {\n                    source = util.relative(this.sourceRoot, source);\n                }\n                if (!this._sources.has(source)) {\n                    return {\n                        line: null,\n                        column: null,\n                        lastColumn: null\n                    };\n                }\n                source = this._sources.indexOf(source);\n                var needle = {\n                    source: source,\n                    originalLine: util.getArg(aArgs, 'line'),\n                    originalColumn: util.getArg(aArgs, 'column')\n                };\n                var index = this._findMapping(needle, this._originalMappings, 'originalLine', 'originalColumn', util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n                if (index >= 0) {\n                    var mapping = this._originalMappings[index];\n                    if (mapping.source === needle.source) {\n                        return {\n                            line: util.getArg(mapping, 'generatedLine', null),\n                            column: util.getArg(mapping, 'generatedColumn', null),\n                            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n                        };\n                    }\n                }\n                return {\n                    line: null,\n                    column: null,\n                    lastColumn: null\n                };\n            };\n            exports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n            function IndexedSourceMapConsumer(aSourceMap) {\n                var sourceMap = aSourceMap;\n                if (typeof aSourceMap === 'string') {\n                    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n                }\n                var version = util.getArg(sourceMap, 'version');\n                var sections = util.getArg(sourceMap, 'sections');\n                if (version != this._version) {\n                    throw new Error('Unsupported version: ' + version);\n                }\n                this._sources = new ArraySet();\n                this._names = new ArraySet();\n                var lastOffset = {\n                    line: -1,\n                    column: 0\n                };\n                this._sections = sections.map(function (s) {\n                    if (s.url) {\n                        throw new Error('Support for url field in sections not implemented.');\n                    }\n                    var offset = util.getArg(s, 'offset');\n                    var offsetLine = util.getArg(offset, 'line');\n                    var offsetColumn = util.getArg(offset, 'column');\n                    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n                        throw new Error('Section offsets must be ordered and non-overlapping.');\n                    }\n                    lastOffset = offset;\n                    return {\n                        generatedOffset: {\n                            generatedLine: offsetLine + 1,\n                            generatedColumn: offsetColumn + 1\n                        },\n                        consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n                    };\n                });\n            }\n            IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n            IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n            IndexedSourceMapConsumer.prototype._version = 3;\n            Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n                get: function () {\n                    var sources = [];\n                    for (var i = 0; i < this._sections.length; i++) {\n                        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n                            sources.push(this._sections[i].consumer.sources[j]);\n                        }\n                    }\n                    return sources;\n                }\n            });\n            IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n                var needle = {\n                    generatedLine: util.getArg(aArgs, 'line'),\n                    generatedColumn: util.getArg(aArgs, 'column')\n                };\n                var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {\n                    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n                    if (cmp) {\n                        return cmp;\n                    }\n                    return needle.generatedColumn - section.generatedOffset.generatedColumn;\n                });\n                var section = this._sections[sectionIndex];\n                if (!section) {\n                    return {\n                        source: null,\n                        line: null,\n                        column: null,\n                        name: null\n                    };\n                }\n                return section.consumer.originalPositionFor({\n                    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n                    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n                    bias: aArgs.bias\n                });\n            };\n            IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n                return this._sections.every(function (s) {\n                    return s.consumer.hasContentsOfAllSources();\n                });\n            };\n            IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n                for (var i = 0; i < this._sections.length; i++) {\n                    var section = this._sections[i];\n                    var content = section.consumer.sourceContentFor(aSource, true);\n                    if (content) {\n                        return content;\n                    }\n                }\n                if (nullOnMissing) {\n                    return null;\n                } else {\n                    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n                }\n            };\n            IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n                for (var i = 0; i < this._sections.length; i++) {\n                    var section = this._sections[i];\n                    if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n                        continue;\n                    }\n                    var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n                    if (generatedPosition) {\n                        var ret = {\n                            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),\n                            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)\n                        };\n                        return ret;\n                    }\n                }\n                return {\n                    line: null,\n                    column: null\n                };\n            };\n            IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n                this.__generatedMappings = [];\n                this.__originalMappings = [];\n                for (var i = 0; i < this._sections.length; i++) {\n                    var section = this._sections[i];\n                    var sectionMappings = section.consumer._generatedMappings;\n                    for (var j = 0; j < sectionMappings.length; j++) {\n                        var mapping = sectionMappings[j];\n                        var source = section.consumer._sources.at(mapping.source);\n                        if (section.consumer.sourceRoot !== null) {\n                            source = util.join(section.consumer.sourceRoot, source);\n                        }\n                        this._sources.add(source);\n                        source = this._sources.indexOf(source);\n                        var name = section.consumer._names.at(mapping.name);\n                        this._names.add(name);\n                        name = this._names.indexOf(name);\n                        var adjustedMapping = {\n                            source: source,\n                            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),\n                            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n                            originalLine: mapping.originalLine,\n                            originalColumn: mapping.originalColumn,\n                            name: name\n                        };\n                        this.__generatedMappings.push(adjustedMapping);\n                        if (typeof adjustedMapping.originalLine === 'number') {\n                            this.__originalMappings.push(adjustedMapping);\n                        }\n                    }\n                }\n                quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n                quickSort(this.__originalMappings, util.compareByOriginalPositions);\n            };\n            exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n        },\n        {\n            '138': 138,\n            '139': 139,\n            '141': 141,\n            '142': 142,\n            '144': 144\n        }\n    ],\n    142: [\n        function (require, module, exports) {\n            function swap(ary, x, y) {\n                var temp = ary[x];\n                ary[x] = ary[y];\n                ary[y] = temp;\n            }\n            function randomIntInRange(low, high) {\n                return Math.round(low + Math.random() * (high - low));\n            }\n            function doQuickSort(ary, comparator, p, r) {\n                if (p < r) {\n                    var pivotIndex = randomIntInRange(p, r);\n                    var i = p - 1;\n                    swap(ary, pivotIndex, r);\n                    var pivot = ary[r];\n                    for (var j = p; j < r; j++) {\n                        if (comparator(ary[j], pivot) <= 0) {\n                            i += 1;\n                            swap(ary, i, j);\n                        }\n                    }\n                    swap(ary, i + 1, j);\n                    var q = i + 1;\n                    doQuickSort(ary, comparator, p, q - 1);\n                    doQuickSort(ary, comparator, q + 1, r);\n                }\n            }\n            exports.quickSort = function (ary, comparator) {\n                doQuickSort(ary, comparator, 0, ary.length - 1);\n            };\n        },\n        {}\n    ],\n    141: [\n        function (require, module, exports) {\n            exports.GREATEST_LOWER_BOUND = 1;\n            exports.LEAST_UPPER_BOUND = 2;\n            function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n                var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n                var cmp = aCompare(aNeedle, aHaystack[mid], true);\n                if (cmp === 0) {\n                    return mid;\n                } else if (cmp > 0) {\n                    if (aHigh - mid > 1) {\n                        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n                    }\n                    if (aBias == exports.LEAST_UPPER_BOUND) {\n                        return aHigh < aHaystack.length ? aHigh : -1;\n                    } else {\n                        return mid;\n                    }\n                } else {\n                    if (mid - aLow > 1) {\n                        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n                    }\n                    if (aBias == exports.LEAST_UPPER_BOUND) {\n                        return mid;\n                    } else {\n                        return aLow < 0 ? -1 : aLow;\n                    }\n                }\n            }\n            exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n                if (aHaystack.length === 0) {\n                    return -1;\n                }\n                var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n                if (index < 0) {\n                    return -1;\n                }\n                while (index - 1 >= 0) {\n                    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n                        break;\n                    }\n                    --index;\n                }\n                return index;\n            };\n        },\n        {}\n    ],\n    139: [\n        function (require, module, exports) {\n            var base64 = require(140);\n            var VLQ_BASE_SHIFT = 5;\n            var VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n            var VLQ_BASE_MASK = VLQ_BASE - 1;\n            var VLQ_CONTINUATION_BIT = VLQ_BASE;\n            function toVLQSigned(aValue) {\n                return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n            }\n            function fromVLQSigned(aValue) {\n                var isNegative = (aValue & 1) === 1;\n                var shifted = aValue >> 1;\n                return isNegative ? -shifted : shifted;\n            }\n            exports.encode = function base64VLQ_encode(aValue) {\n                var encoded = '';\n                var digit;\n                var vlq = toVLQSigned(aValue);\n                do {\n                    digit = vlq & VLQ_BASE_MASK;\n                    vlq >>>= VLQ_BASE_SHIFT;\n                    if (vlq > 0) {\n                        digit |= VLQ_CONTINUATION_BIT;\n                    }\n                    encoded += base64.encode(digit);\n                } while (vlq > 0);\n                return encoded;\n            };\n            exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n                var strLen = aStr.length;\n                var result = 0;\n                var shift = 0;\n                var continuation, digit;\n                do {\n                    if (aIndex >= strLen) {\n                        throw new Error('Expected more digits in base 64 VLQ value.');\n                    }\n                    digit = base64.decode(aStr.charCodeAt(aIndex++));\n                    if (digit === -1) {\n                        throw new Error('Invalid base64 digit: ' + aStr.charAt(aIndex - 1));\n                    }\n                    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n                    digit &= VLQ_BASE_MASK;\n                    result = result + (digit << shift);\n                    shift += VLQ_BASE_SHIFT;\n                } while (continuation);\n                aOutParam.value = fromVLQSigned(result);\n                aOutParam.rest = aIndex;\n            };\n        },\n        { '140': 140 }\n    ],\n    140: [\n        function (require, module, exports) {\n            var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n            exports.encode = function (number) {\n                if (0 <= number && number < intToCharMap.length) {\n                    return intToCharMap[number];\n                }\n                throw new TypeError('Must be between 0 and 63: ' + number);\n            };\n            exports.decode = function (charCode) {\n                var bigA = 65;\n                var bigZ = 90;\n                var littleA = 97;\n                var littleZ = 122;\n                var zero = 48;\n                var nine = 57;\n                var plus = 43;\n                var slash = 47;\n                var littleOffset = 26;\n                var numberOffset = 52;\n                if (bigA <= charCode && charCode <= bigZ) {\n                    return charCode - bigA;\n                }\n                if (littleA <= charCode && charCode <= littleZ) {\n                    return charCode - littleA + littleOffset;\n                }\n                if (zero <= charCode && charCode <= nine) {\n                    return charCode - zero + numberOffset;\n                }\n                if (charCode == plus) {\n                    return 62;\n                }\n                if (charCode == slash) {\n                    return 63;\n                }\n                return -1;\n            };\n        },\n        {}\n    ],\n    138: [\n        function (require, module, exports) {\n            var util = require(144);\n            var has = Object.prototype.hasOwnProperty;\n            function ArraySet() {\n                this._array = [];\n                this._set = Object.create(null);\n            }\n            ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n                var set = new ArraySet();\n                for (var i = 0, len = aArray.length; i < len; i++) {\n                    set.add(aArray[i], aAllowDuplicates);\n                }\n                return set;\n            };\n            ArraySet.prototype.size = function ArraySet_size() {\n                return Object.getOwnPropertyNames(this._set).length;\n            };\n            ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n                var sStr = util.toSetString(aStr);\n                var isDuplicate = has.call(this._set, sStr);\n                var idx = this._array.length;\n                if (!isDuplicate || aAllowDuplicates) {\n                    this._array.push(aStr);\n                }\n                if (!isDuplicate) {\n                    this._set[sStr] = idx;\n                }\n            };\n            ArraySet.prototype.has = function ArraySet_has(aStr) {\n                var sStr = util.toSetString(aStr);\n                return has.call(this._set, sStr);\n            };\n            ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n                var sStr = util.toSetString(aStr);\n                if (has.call(this._set, sStr)) {\n                    return this._set[sStr];\n                }\n                throw new Error('\"' + aStr + '\" is not in the set.');\n            };\n            ArraySet.prototype.at = function ArraySet_at(aIdx) {\n                if (aIdx >= 0 && aIdx < this._array.length) {\n                    return this._array[aIdx];\n                }\n                throw new Error('No element indexed by ' + aIdx);\n            };\n            ArraySet.prototype.toArray = function ArraySet_toArray() {\n                return this._array.slice();\n            };\n            exports.ArraySet = ArraySet;\n        },\n        { '144': 144 }\n    ],\n    144: [\n        function (require, module, exports) {\n            function getArg(aArgs, aName, aDefaultValue) {\n                if (aName in aArgs) {\n                    return aArgs[aName];\n                } else if (arguments.length === 3) {\n                    return aDefaultValue;\n                } else {\n                    throw new Error('\"' + aName + '\" is a required argument.');\n                }\n            }\n            exports.getArg = getArg;\n            var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n            var dataUrlRegexp = /^data:.+\\,.+$/;\n            function urlParse(aUrl) {\n                var match = aUrl.match(urlRegexp);\n                if (!match) {\n                    return null;\n                }\n                return {\n                    scheme: match[1],\n                    auth: match[2],\n                    host: match[3],\n                    port: match[4],\n                    path: match[5]\n                };\n            }\n            exports.urlParse = urlParse;\n            function urlGenerate(aParsedUrl) {\n                var url = '';\n                if (aParsedUrl.scheme) {\n                    url += aParsedUrl.scheme + ':';\n                }\n                url += '//';\n                if (aParsedUrl.auth) {\n                    url += aParsedUrl.auth + '@';\n                }\n                if (aParsedUrl.host) {\n                    url += aParsedUrl.host;\n                }\n                if (aParsedUrl.port) {\n                    url += ':' + aParsedUrl.port;\n                }\n                if (aParsedUrl.path) {\n                    url += aParsedUrl.path;\n                }\n                return url;\n            }\n            exports.urlGenerate = urlGenerate;\n            function normalize(aPath) {\n                var path = aPath;\n                var url = urlParse(aPath);\n                if (url) {\n                    if (!url.path) {\n                        return aPath;\n                    }\n                    path = url.path;\n                }\n                var isAbsolute = exports.isAbsolute(path);\n                var parts = path.split(/\\/+/);\n                for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n                    part = parts[i];\n                    if (part === '.') {\n                        parts.splice(i, 1);\n                    } else if (part === '..') {\n                        up++;\n                    } else if (up > 0) {\n                        if (part === '') {\n                            parts.splice(i + 1, up);\n                            up = 0;\n                        } else {\n                            parts.splice(i, 2);\n                            up--;\n                        }\n                    }\n                }\n                path = parts.join('/');\n                if (path === '') {\n                    path = isAbsolute ? '/' : '.';\n                }\n                if (url) {\n                    url.path = path;\n                    return urlGenerate(url);\n                }\n                return path;\n            }\n            exports.normalize = normalize;\n            function join(aRoot, aPath) {\n                if (aRoot === '') {\n                    aRoot = '.';\n                }\n                if (aPath === '') {\n                    aPath = '.';\n                }\n                var aPathUrl = urlParse(aPath);\n                var aRootUrl = urlParse(aRoot);\n                if (aRootUrl) {\n                    aRoot = aRootUrl.path || '/';\n                }\n                if (aPathUrl && !aPathUrl.scheme) {\n                    if (aRootUrl) {\n                        aPathUrl.scheme = aRootUrl.scheme;\n                    }\n                    return urlGenerate(aPathUrl);\n                }\n                if (aPathUrl || aPath.match(dataUrlRegexp)) {\n                    return aPath;\n                }\n                if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n                    aRootUrl.host = aPath;\n                    return urlGenerate(aRootUrl);\n                }\n                var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n                if (aRootUrl) {\n                    aRootUrl.path = joined;\n                    return urlGenerate(aRootUrl);\n                }\n                return joined;\n            }\n            exports.join = join;\n            exports.isAbsolute = function (aPath) {\n                return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n            };\n            function relative(aRoot, aPath) {\n                if (aRoot === '') {\n                    aRoot = '.';\n                }\n                aRoot = aRoot.replace(/\\/$/, '');\n                var level = 0;\n                while (aPath.indexOf(aRoot + '/') !== 0) {\n                    var index = aRoot.lastIndexOf('/');\n                    if (index < 0) {\n                        return aPath;\n                    }\n                    aRoot = aRoot.slice(0, index);\n                    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n                        return aPath;\n                    }\n                    ++level;\n                }\n                return Array(level + 1).join('../') + aPath.substr(aRoot.length + 1);\n            }\n            exports.relative = relative;\n            var supportsNullProto = function () {\n                var obj = Object.create(null);\n                return !('__proto__' in obj);\n            }();\n            function identity(s) {\n                return s;\n            }\n            function toSetString(aStr) {\n                if (isProtoString(aStr)) {\n                    return '$' + aStr;\n                }\n                return aStr;\n            }\n            exports.toSetString = supportsNullProto ? identity : toSetString;\n            function fromSetString(aStr) {\n                if (isProtoString(aStr)) {\n                    return aStr.slice(1);\n                }\n                return aStr;\n            }\n            exports.fromSetString = supportsNullProto ? identity : fromSetString;\n            function isProtoString(s) {\n                if (!s) {\n                    return false;\n                }\n                var length = s.length;\n                if (length < 9) {\n                    return false;\n                }\n                if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {\n                    return false;\n                }\n                for (var i = length - 10; i >= 0; i--) {\n                    if (s.charCodeAt(i) !== 36) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n                var cmp = mappingA.source - mappingB.source;\n                if (cmp !== 0) {\n                    return cmp;\n                }\n                cmp = mappingA.originalLine - mappingB.originalLine;\n                if (cmp !== 0) {\n                    return cmp;\n                }\n                cmp = mappingA.originalColumn - mappingB.originalColumn;\n                if (cmp !== 0 || onlyCompareOriginal) {\n                    return cmp;\n                }\n                cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n                if (cmp !== 0) {\n                    return cmp;\n                }\n                cmp = mappingA.generatedLine - mappingB.generatedLine;\n                if (cmp !== 0) {\n                    return cmp;\n                }\n                return mappingA.name - mappingB.name;\n            }\n            exports.compareByOriginalPositions = compareByOriginalPositions;\n            function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n                var cmp = mappingA.generatedLine - mappingB.generatedLine;\n                if (cmp !== 0) {\n                    return cmp;\n                }\n                cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n                if (cmp !== 0 || onlyCompareGenerated) {\n                    return cmp;\n                }\n                cmp = mappingA.source - mappingB.source;\n                if (cmp !== 0) {\n                    return cmp;\n                }\n                cmp = mappingA.originalLine - mappingB.originalLine;\n                if (cmp !== 0) {\n                    return cmp;\n                }\n                cmp = mappingA.originalColumn - mappingB.originalColumn;\n                if (cmp !== 0) {\n                    return cmp;\n                }\n                return mappingA.name - mappingB.name;\n            }\n            exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n            function strcmp(aStr1, aStr2) {\n                if (aStr1 === aStr2) {\n                    return 0;\n                }\n                if (aStr1 > aStr2) {\n                    return 1;\n                }\n                return -1;\n            }\n            function compareByGeneratedPositionsInflated(mappingA, mappingB) {\n                var cmp = mappingA.generatedLine - mappingB.generatedLine;\n                if (cmp !== 0) {\n                    return cmp;\n                }\n                cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n                if (cmp !== 0) {\n                    return cmp;\n                }\n                cmp = strcmp(mappingA.source, mappingB.source);\n                if (cmp !== 0) {\n                    return cmp;\n                }\n                cmp = mappingA.originalLine - mappingB.originalLine;\n                if (cmp !== 0) {\n                    return cmp;\n                }\n                cmp = mappingA.originalColumn - mappingB.originalColumn;\n                if (cmp !== 0) {\n                    return cmp;\n                }\n                return strcmp(mappingA.name, mappingB.name);\n            }\n            exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n        },\n        {}\n    ],\n    136: [\n        function (require, module, exports) {\n            (function (root, factory) {\n                'use strict';\n                if (typeof define === 'function' && define.amd) {\n                    define('stack-generator', ['stackframe'], factory);\n                } else if (typeof exports === 'object') {\n                    module.exports = factory(require(137));\n                } else {\n                    root.StackGenerator = factory(root.StackFrame);\n                }\n            }(this, function (StackFrame) {\n                return {\n                    backtrace: function StackGenerator$$backtrace(opts) {\n                        var stack = [];\n                        var maxStackSize = 10;\n                        if (typeof opts === 'object' && typeof opts.maxStackSize === 'number') {\n                            maxStackSize = opts.maxStackSize;\n                        }\n                        var curr = arguments.callee;\n                        while (curr && stack.length < maxStackSize && curr['arguments']) {\n                            var args = new Array(curr['arguments'].length);\n                            for (var i = 0; i < args.length; ++i) {\n                                args[i] = curr['arguments'][i];\n                            }\n                            if (/function(?:\\s+([\\w$]+))+\\s*\\(/.test(curr.toString())) {\n                                stack.push(new StackFrame({\n                                    functionName: RegExp.$1 || undefined,\n                                    args: args\n                                }));\n                            } else {\n                                stack.push(new StackFrame({ args: args }));\n                            }\n                            try {\n                                curr = curr.caller;\n                            } catch (e) {\n                                break;\n                            }\n                        }\n                        return stack;\n                    }\n                };\n            }));\n        },\n        { '137': 137 }\n    ],\n    96: [\n        function (require, module, exports) {\n            (function (root, factory) {\n                'use strict';\n                if (typeof define === 'function' && define.amd) {\n                    define('error-stack-parser', ['stackframe'], factory);\n                } else if (typeof exports === 'object') {\n                    module.exports = factory(require(137));\n                } else {\n                    root.ErrorStackParser = factory(root.StackFrame);\n                }\n            }(this, function ErrorStackParser(StackFrame) {\n                'use strict';\n                var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\n                var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\n                var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\n                return {\n                    parse: function ErrorStackParser$$parse(error) {\n                        if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n                            return this.parseOpera(error);\n                        } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n                            return this.parseV8OrIE(error);\n                        } else if (error.stack) {\n                            return this.parseFFOrSafari(error);\n                        } else {\n                            throw new Error('Cannot parse given Error object');\n                        }\n                    },\n                    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n                        if (urlLike.indexOf(':') === -1) {\n                            return [urlLike];\n                        }\n                        var regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n                        var parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n                        return [\n                            parts[1],\n                            parts[2] || undefined,\n                            parts[3] || undefined\n                        ];\n                    },\n                    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n                        var filtered = error.stack.split('\\n').filter(function (line) {\n                            return !!line.match(CHROME_IE_STACK_REGEXP);\n                        }, this);\n                        return filtered.map(function (line) {\n                            if (line.indexOf('(eval ') > -1) {\n                                line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n                            }\n                            var sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(');\n                            var location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n                            sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;\n                            var tokens = sanitizedLine.split(/\\s+/).slice(1);\n                            var locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n                            var functionName = tokens.join(' ') || undefined;\n                            var fileName = [\n                                'eval',\n                                '<anonymous>'\n                            ].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n                            return new StackFrame({\n                                functionName: functionName,\n                                fileName: fileName,\n                                lineNumber: locationParts[1],\n                                columnNumber: locationParts[2],\n                                source: line\n                            });\n                        }, this);\n                    },\n                    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n                        var filtered = error.stack.split('\\n').filter(function (line) {\n                            return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n                        }, this);\n                        return filtered.map(function (line) {\n                            if (line.indexOf(' > eval') > -1) {\n                                line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, ':$1');\n                            }\n                            if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n                                return new StackFrame({ functionName: line });\n                            } else {\n                                var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n                                var matches = line.match(functionNameRegex);\n                                var functionName = matches && matches[1] ? matches[1] : undefined;\n                                var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));\n                                return new StackFrame({\n                                    functionName: functionName,\n                                    fileName: locationParts[0],\n                                    lineNumber: locationParts[1],\n                                    columnNumber: locationParts[2],\n                                    source: line\n                                });\n                            }\n                        }, this);\n                    },\n                    parseOpera: function ErrorStackParser$$parseOpera(e) {\n                        if (!e.stacktrace || e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n                            return this.parseOpera9(e);\n                        } else if (!e.stack) {\n                            return this.parseOpera10(e);\n                        } else {\n                            return this.parseOpera11(e);\n                        }\n                    },\n                    parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n                        var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n                        var lines = e.message.split('\\n');\n                        var result = [];\n                        for (var i = 2, len = lines.length; i < len; i += 2) {\n                            var match = lineRE.exec(lines[i]);\n                            if (match) {\n                                result.push(new StackFrame({\n                                    fileName: match[2],\n                                    lineNumber: match[1],\n                                    source: lines[i]\n                                }));\n                            }\n                        }\n                        return result;\n                    },\n                    parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n                        var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n                        var lines = e.stacktrace.split('\\n');\n                        var result = [];\n                        for (var i = 0, len = lines.length; i < len; i += 2) {\n                            var match = lineRE.exec(lines[i]);\n                            if (match) {\n                                result.push(new StackFrame({\n                                    functionName: match[3] || undefined,\n                                    fileName: match[2],\n                                    lineNumber: match[1],\n                                    source: lines[i]\n                                }));\n                            }\n                        }\n                        return result;\n                    },\n                    parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n                        var filtered = error.stack.split('\\n').filter(function (line) {\n                            return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n                        }, this);\n                        return filtered.map(function (line) {\n                            var tokens = line.split('@');\n                            var locationParts = this.extractLocation(tokens.pop());\n                            var functionCall = tokens.shift() || '';\n                            var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, '$2').replace(/\\([^)]*\\)/g, '') || undefined;\n                            var argsRaw;\n                            if (functionCall.match(/\\(([^)]*)\\)/)) {\n                                argsRaw = functionCall.replace(/^[^(]+\\(([^)]*)\\)$/, '$1');\n                            }\n                            var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');\n                            return new StackFrame({\n                                functionName: functionName,\n                                args: args,\n                                fileName: locationParts[0],\n                                lineNumber: locationParts[1],\n                                columnNumber: locationParts[2],\n                                source: line\n                            });\n                        }, this);\n                    }\n                };\n            }));\n        },\n        { '137': 137 }\n    ],\n    137: [\n        function (require, module, exports) {\n            (function (root, factory) {\n                'use strict';\n                if (typeof define === 'function' && define.amd) {\n                    define('stackframe', [], factory);\n                } else if (typeof exports === 'object') {\n                    module.exports = factory();\n                } else {\n                    root.StackFrame = factory();\n                }\n            }(this, function () {\n                'use strict';\n                function _isNumber(n) {\n                    return !isNaN(parseFloat(n)) && isFinite(n);\n                }\n                function _capitalize(str) {\n                    return str.charAt(0).toUpperCase() + str.substring(1);\n                }\n                function _getter(p) {\n                    return function () {\n                        return this[p];\n                    };\n                }\n                var booleanProps = [\n                    'isConstructor',\n                    'isEval',\n                    'isNative',\n                    'isToplevel'\n                ];\n                var numericProps = [\n                    'columnNumber',\n                    'lineNumber'\n                ];\n                var stringProps = [\n                    'fileName',\n                    'functionName',\n                    'source'\n                ];\n                var arrayProps = ['args'];\n                var objectProps = ['evalOrigin'];\n                var props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);\n                function StackFrame(obj) {\n                    if (!obj)\n                        return;\n                    for (var i = 0; i < props.length; i++) {\n                        if (obj[props[i]] !== undefined) {\n                            this['set' + _capitalize(props[i])](obj[props[i]]);\n                        }\n                    }\n                }\n                StackFrame.prototype = {\n                    getArgs: function () {\n                        return this.args;\n                    },\n                    setArgs: function (v) {\n                        if (Object.prototype.toString.call(v) !== '[object Array]') {\n                            throw new TypeError('Args must be an Array');\n                        }\n                        this.args = v;\n                    },\n                    getEvalOrigin: function () {\n                        return this.evalOrigin;\n                    },\n                    setEvalOrigin: function (v) {\n                        if (v instanceof StackFrame) {\n                            this.evalOrigin = v;\n                        } else if (v instanceof Object) {\n                            this.evalOrigin = new StackFrame(v);\n                        } else {\n                            throw new TypeError('Eval Origin must be an Object or StackFrame');\n                        }\n                    },\n                    toString: function () {\n                        var fileName = this.getFileName() || '';\n                        var lineNumber = this.getLineNumber() || '';\n                        var columnNumber = this.getColumnNumber() || '';\n                        var functionName = this.getFunctionName() || '';\n                        if (this.getIsEval()) {\n                            if (fileName) {\n                                return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n                            }\n                            return '[eval]:' + lineNumber + ':' + columnNumber;\n                        }\n                        if (functionName) {\n                            return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n                        }\n                        return fileName + ':' + lineNumber + ':' + columnNumber;\n                    }\n                };\n                StackFrame.fromString = function StackFrame$$fromString(str) {\n                    var argsStartIndex = str.indexOf('(');\n                    var argsEndIndex = str.lastIndexOf(')');\n                    var functionName = str.substring(0, argsStartIndex);\n                    var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');\n                    var locationString = str.substring(argsEndIndex + 1);\n                    if (locationString.indexOf('@') === 0) {\n                        var parts = /@(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(locationString, '');\n                        var fileName = parts[1];\n                        var lineNumber = parts[2];\n                        var columnNumber = parts[3];\n                    }\n                    return new StackFrame({\n                        functionName: functionName,\n                        args: args || undefined,\n                        fileName: fileName,\n                        lineNumber: lineNumber || undefined,\n                        columnNumber: columnNumber || undefined\n                    });\n                };\n                for (var i = 0; i < booleanProps.length; i++) {\n                    StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n                    StackFrame.prototype['set' + _capitalize(booleanProps[i])] = function (p) {\n                        return function (v) {\n                            this[p] = Boolean(v);\n                        };\n                    }(booleanProps[i]);\n                }\n                for (var j = 0; j < numericProps.length; j++) {\n                    StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n                    StackFrame.prototype['set' + _capitalize(numericProps[j])] = function (p) {\n                        return function (v) {\n                            if (!_isNumber(v)) {\n                                throw new TypeError(p + ' must be a Number');\n                            }\n                            this[p] = Number(v);\n                        };\n                    }(numericProps[j]);\n                }\n                for (var k = 0; k < stringProps.length; k++) {\n                    StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n                    StackFrame.prototype['set' + _capitalize(stringProps[k])] = function (p) {\n                        return function (v) {\n                            this[p] = String(v);\n                        };\n                    }(stringProps[k]);\n                }\n                return StackFrame;\n            }));\n        },\n        {}\n    ],\n    123: [\n        function (require, module, exports) {\n            'use strict';\n            var ErrorToString = Error.prototype.toString;\n            function prepareStackTrace(err, trace) {\n                var errorString = ErrorToString.call(err);\n                if (trace.length === 0)\n                    return errorString;\n                return ''.concat(errorString, '\\n    at ').concat(trace.join('\\n    at '));\n            }\n            module.exports = prepareStackTrace;\n        },\n        {}\n    ]\n}, {}, [3]);","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","const StackTrace = require(146);\nconst prepareStackTrace = require(123);\nconst uncaught = require(155);\n\nconst logger = require(2);\n\n//\n// Sourced from the StackTrace example from CabinJS docs\n// <https://github.com/cabinjs/cabin#stacktrace>\n//\nuncaught.start();\nuncaught.addListener(function(err, event) {\n  if (!err) {\n    if (typeof ErrorEvent === 'function' && event instanceof ErrorEvent)\n      return logger.error(event.message, { event });\n    logger.error({ event });\n    return;\n  }\n\n  // this will transform the error's `stack` property\n  // to be consistently similar to Gecko and V8 stackframes\n  StackTrace.fromError(err)\n    .then(stackframes => {\n      err.stack = prepareStackTrace(err, stackframes);\n      logger.error(err);\n    })\n    .catch(err_ => {\n      logger.error(err);\n      logger.error(err_);\n    });\n});\n\nmodule.exports = uncaught;\n","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"uncaught\"] = factory();\n\telse\n\t\troot[\"uncaught\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @overview Module for handle uncaught errors and promises rejections\n\t */\n\n\t'use strict';\n\n\t/**\n\t * Defines execution environment\n\t */\n\n\tvar isBrowser = typeof window !== 'undefined';\n\n\t/**\n\t * Listeners list, which are registered for uncaught errors and promises rejections\n\t */\n\tvar listeners = [];\n\n\t/**\n\t * Sign of module own handlers registration\n\t */\n\tvar handlersAreRegistered = false;\n\n\t/**\n\t * Sign of module own handlers working status\n\t */\n\tvar handlersAreTurnedOn = false;\n\n\tmodule.exports = {\n\n\t    /**\n\t     * Starts handling for uncaught errors and promises rejections\n\t     */\n\t    start: function start() {\n\t        if (handlersAreTurnedOn) {\n\t            return;\n\t        }\n\n\t        if (!handlersAreRegistered) {\n\t            if (isBrowser) {\n\t                // Listen to uncaught errors\n\t                window.addEventListener('error', browserErrorHandler);\n\t                // Listen to uncaught promises rejections\n\t                window.addEventListener('unhandledrejection', browserRejectionHandler);\n\t            } else {\n\t                process.on('uncaughtException', nodeErrorHandler);\n\t                process.on('unhandledRejection', nodeRejectionHandler);\n\t            }\n\n\t            handlersAreRegistered = true;\n\t        }\n\n\t        handlersAreTurnedOn = true;\n\t    },\n\n\n\t    /**\n\t     * Stops handling\n\t     */\n\t    stop: function stop() {\n\t        if (!handlersAreTurnedOn) {\n\t            return;\n\t        }\n\n\t        if (isBrowser) {\n\t            window.removeEventListener('error', browserErrorHandler);\n\t            window.removeEventListener('unhandledrejection', browserRejectionHandler);\n\n\t            handlersAreRegistered = false;\n\t        }\n\n\t        handlersAreTurnedOn = false;\n\t    },\n\n\n\t    /**\n\t     * Adds listener to list\n\t     * @param {Function} listener\n\t     */\n\t    addListener: function addListener(listener) {\n\t        if (typeof listener === 'function') {\n\t            listeners.push(listener);\n\t        }\n\t    },\n\n\n\t    /**\n\t     * Removes listener from list\n\t     * @param {Function} listener\n\t     */\n\t    removeListener: function removeListener(listener) {\n\t        var index = listeners.indexOf(listener);\n\n\t        if (index > -1) {\n\t            listeners.splice(index, 1);\n\t        }\n\t    },\n\n\n\t    /**\n\t     * Removes all listeners\n\t     */\n\t    removeAllListeners: function removeAllListeners() {\n\t        listeners.length = 0;\n\t    },\n\n\n\t    /**\n\t     * Flushes module: stops handling and removes all listeners\n\t     */\n\t    flush: function flush() {\n\t        this.removeAllListeners();\n\t        this.stop();\n\t    }\n\t};\n\n\t/**\n\t * Handler for browser uncaught errors\n\t * @param {Object} event\n\t */\n\tfunction browserErrorHandler(event) {\n\t    var error = event ? event.error : undefined;\n\t    callListeners(error, event);\n\t}\n\n\t/**\n\t * Handler for browser uncaught promises rejections\n\t * @param {Object} event\n\t */\n\tfunction browserRejectionHandler(event) {\n\t    var error = event ? event.reason : undefined;\n\t    callListeners(error, event);\n\t}\n\n\t/**\n\t * Handler for Node.js uncaught errors\n\t * @param {Object} error\n\t */\n\tfunction nodeErrorHandler(error) {\n\t    if (handlersAreTurnedOn) {\n\t        callListeners(error, null);\n\t    }\n\t}\n\n\t/**\n\t * Handler for Node.js uncaught promises rejections\n\t * @param {Object} reason\n\t */\n\tfunction nodeRejectionHandler(reason) {\n\t    if (handlersAreTurnedOn) {\n\t        callListeners(reason, null);\n\t    }\n\t}\n\n\t/**\n\t * Send error data to all listeners\n\t * @param {Object} error\n\t * @param {Object} event\n\t */\n\tfunction callListeners(error, event) {\n\t    listeners.forEach(function (listener) {\n\t        listener(error, event);\n\t    });\n\t}\n\n/***/ }\n/******/ ])\n});\n;","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stacktrace', ['error-stack-parser', 'stack-generator', 'stacktrace-gps'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require(96), require(136), require(145));\n    } else {\n        root.StackTrace = factory(root.ErrorStackParser, root.StackGenerator, root.StackTraceGPS);\n    }\n}(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {\n    var _options = {\n        filter: function(stackframe) {\n            // Filter out stackframes for this library by default\n            return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 &&\n                (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 &&\n                (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 &&\n                (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;\n        },\n        sourceCache: {}\n    };\n\n    var _generateError = function StackTrace$$GenerateError() {\n        try {\n            // Error must be thrown to get stack in IE\n            throw new Error();\n        } catch (err) {\n            return err;\n        }\n    };\n\n    /**\n     * Merge 2 given Objects. If a conflict occurs the second object wins.\n     * Does not do deep merges.\n     *\n     * @param {Object} first base object\n     * @param {Object} second overrides\n     * @returns {Object} merged first and second\n     * @private\n     */\n    function _merge(first, second) {\n        var target = {};\n\n        [first, second].forEach(function(obj) {\n            for (var prop in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n                    target[prop] = obj[prop];\n                }\n            }\n            return target;\n        });\n\n        return target;\n    }\n\n    function _isShapedLikeParsableError(err) {\n        return err.stack || err['opera#sourceloc'];\n    }\n\n    function _filtered(stackframes, filter) {\n        if (typeof filter === 'function') {\n            return stackframes.filter(filter);\n        }\n        return stackframes;\n    }\n\n    return {\n        /**\n         * Get a backtrace from invocation point.\n         *\n         * @param {Object} opts\n         * @returns {Array} of StackFrame\n         */\n        get: function StackTrace$$get(opts) {\n            var err = _generateError();\n            return _isShapedLikeParsableError(err) ? this.fromError(err, opts) : this.generateArtificially(opts);\n        },\n\n        /**\n         * Get a backtrace from invocation point.\n         * IMPORTANT: Does not handle source maps or guess function names!\n         *\n         * @param {Object} opts\n         * @returns {Array} of StackFrame\n         */\n        getSync: function StackTrace$$getSync(opts) {\n            opts = _merge(_options, opts);\n            var err = _generateError();\n            var stack = _isShapedLikeParsableError(err) ? ErrorStackParser.parse(err) : StackGenerator.backtrace(opts);\n            return _filtered(stack, opts.filter);\n        },\n\n        /**\n         * Given an error object, parse it.\n         *\n         * @param {Error} error object\n         * @param {Object} opts\n         * @returns {Promise} for Array[StackFrame}\n         */\n        fromError: function StackTrace$$fromError(error, opts) {\n            opts = _merge(_options, opts);\n            var gps = new StackTraceGPS(opts);\n            return new Promise(function(resolve) {\n                var stackframes = _filtered(ErrorStackParser.parse(error), opts.filter);\n                resolve(Promise.all(stackframes.map(function(sf) {\n                    return new Promise(function(resolve) {\n                        function resolveOriginal() {\n                            resolve(sf);\n                        }\n\n                        gps.pinpoint(sf).then(resolve, resolveOriginal)['catch'](resolveOriginal);\n                    });\n                })));\n            }.bind(this));\n        },\n\n        /**\n         * Use StackGenerator to generate a backtrace.\n         *\n         * @param {Object} opts\n         * @returns {Promise} of Array[StackFrame]\n         */\n        generateArtificially: function StackTrace$$generateArtificially(opts) {\n            opts = _merge(_options, opts);\n            var stackFrames = StackGenerator.backtrace(opts);\n            if (typeof opts.filter === 'function') {\n                stackFrames = stackFrames.filter(opts.filter);\n            }\n            return Promise.resolve(stackFrames);\n        },\n\n        /**\n         * Given a function, wrap it such that invocations trigger a callback that\n         * is called with a stack trace.\n         *\n         * @param {Function} fn to be instrumented\n         * @param {Function} callback function to call with a stack trace on invocation\n         * @param {Function} errback optional function to call with error if unable to get stack trace.\n         * @param {Object} thisArg optional context object (e.g. window)\n         */\n        instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {\n            if (typeof fn !== 'function') {\n                throw new Error('Cannot instrument non-function object');\n            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n                // Already instrumented, return given Function\n                return fn;\n            }\n\n            var instrumented = function StackTrace$$instrumented() {\n                try {\n                    this.get().then(callback, errback)['catch'](errback);\n                    return fn.apply(thisArg || this, arguments);\n                } catch (e) {\n                    if (_isShapedLikeParsableError(e)) {\n                        this.fromError(e).then(callback, errback)['catch'](errback);\n                    }\n                    throw e;\n                }\n            }.bind(this);\n            instrumented.__stacktraceOriginalFn = fn;\n\n            return instrumented;\n        },\n\n        /**\n         * Given a function that has been instrumented,\n         * revert the function to it's original (non-instrumented) state.\n         *\n         * @param {Function} fn to de-instrument\n         */\n        deinstrument: function StackTrace$$deinstrument(fn) {\n            if (typeof fn !== 'function') {\n                throw new Error('Cannot de-instrument non-function object');\n            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n                return fn.__stacktraceOriginalFn;\n            } else {\n                // Function not instrumented, return original\n                return fn;\n            }\n        },\n\n        /**\n         * Given an error message and Array of StackFrames, serialize and POST to given URL.\n         *\n         * @param {Array} stackframes\n         * @param {String} url\n         * @param {String} errorMsg\n         * @param {Object} requestOptions\n         */\n        report: function StackTrace$$report(stackframes, url, errorMsg, requestOptions) {\n            return new Promise(function(resolve, reject) {\n                var req = new XMLHttpRequest();\n                req.onerror = reject;\n                req.onreadystatechange = function onreadystatechange() {\n                    if (req.readyState === 4) {\n                        if (req.status >= 200 && req.status < 400) {\n                            resolve(req.responseText);\n                        } else {\n                            reject(new Error('POST to ' + url + ' failed with status: ' + req.status));\n                        }\n                    }\n                };\n                req.open('post', url);\n\n                // Set request headers\n                req.setRequestHeader('Content-Type', 'application/json');\n                if (requestOptions && typeof requestOptions.headers === 'object') {\n                    var headers = requestOptions.headers;\n                    for (var header in headers) {\n                        if (Object.prototype.hasOwnProperty.call(headers, header)) {\n                            req.setRequestHeader(header, headers[header]);\n                        }\n                    }\n                }\n\n                var reportPayload = {stack: stackframes};\n                if (errorMsg !== undefined && errorMsg !== null) {\n                    reportPayload.message = errorMsg;\n                }\n\n                req.send(JSON.stringify(reportPayload));\n            });\n        }\n    };\n}));\n","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stacktrace-gps', ['source-map', 'stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require(143), require(137));\n    } else {\n        root.StackTraceGPS = factory(root.SourceMap || root.sourceMap, root.StackFrame);\n    }\n}(this, function(SourceMap, StackFrame) {\n    'use strict';\n\n    /**\n     * Make a X-Domain request to url and callback.\n     *\n     * @param {String} url\n     * @returns {Promise} with response text if fulfilled\n     */\n    function _xdr(url) {\n        return new Promise(function(resolve, reject) {\n            var req = new XMLHttpRequest();\n            req.open('get', url);\n            req.onerror = reject;\n            req.onreadystatechange = function onreadystatechange() {\n                if (req.readyState === 4) {\n                    if ((req.status >= 200 && req.status < 300) ||\n                        (url.substr(0, 7) === 'file://' && req.responseText)) {\n                        resolve(req.responseText);\n                    } else {\n                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));\n                    }\n                }\n            };\n            req.send();\n        });\n\n    }\n\n    /**\n     * Convert a Base64-encoded string into its original representation.\n     * Used for inline sourcemaps.\n     *\n     * @param {String} b64str Base-64 encoded string\n     * @returns {String} original representation of the base64-encoded string.\n     */\n    function _atob(b64str) {\n        if (typeof window !== 'undefined' && window.atob) {\n            return window.atob(b64str);\n        } else {\n            throw new Error('You must supply a polyfill for window.atob in this environment');\n        }\n    }\n\n    function _parseJson(string) {\n        if (typeof JSON !== 'undefined' && JSON.parse) {\n            return JSON.parse(string);\n        } else {\n            throw new Error('You must supply a polyfill for JSON.parse in this environment');\n        }\n    }\n\n    function _findFunctionName(source, lineNumber/*, columnNumber*/) {\n        var syntaxes = [\n            // {name} = function ({args}) TODO args capture\n            /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/,\n            // function {name}({args}) m[1]=name m[2]=args\n            /function\\s+([^('\"`]*?)\\s*\\(([^)]*)\\)/,\n            // {name} = eval()\n            /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/,\n            // fn_name() {\n            /\\b(?!(?:if|for|switch|while|with|catch)\\b)(?:(?:static)\\s+)?(\\S+)\\s*\\(.*?\\)\\s*\\{/,\n            // {name} = () => {\n            /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*\\(.*?\\)\\s*=>/\n        ];\n        var lines = source.split('\\n');\n\n        // Walk backwards in the source lines until we find the line which matches one of the patterns above\n        var code = '';\n        var maxLines = Math.min(lineNumber, 20);\n        for (var i = 0; i < maxLines; ++i) {\n            // lineNo is 1-based, source[] is 0-based\n            var line = lines[lineNumber - i - 1];\n            var commentPos = line.indexOf('//');\n            if (commentPos >= 0) {\n                line = line.substr(0, commentPos);\n            }\n\n            if (line) {\n                code = line + code;\n                var len = syntaxes.length;\n                for (var index = 0; index < len; index++) {\n                    var m = syntaxes[index].exec(code);\n                    if (m && m[1]) {\n                        return m[1];\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n\n    function _ensureSupportedEnvironment() {\n        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {\n            throw new Error('Unable to consume source maps in older browsers');\n        }\n    }\n\n    function _ensureStackFrameIsLegit(stackframe) {\n        if (typeof stackframe !== 'object') {\n            throw new TypeError('Given StackFrame is not an object');\n        } else if (typeof stackframe.fileName !== 'string') {\n            throw new TypeError('Given file name is not a String');\n        } else if (typeof stackframe.lineNumber !== 'number' ||\n            stackframe.lineNumber % 1 !== 0 ||\n            stackframe.lineNumber < 1) {\n            throw new TypeError('Given line number must be a positive integer');\n        } else if (typeof stackframe.columnNumber !== 'number' ||\n            stackframe.columnNumber % 1 !== 0 ||\n            stackframe.columnNumber < 0) {\n            throw new TypeError('Given column number must be a non-negative integer');\n        }\n        return true;\n    }\n\n    function _findSourceMappingURL(source) {\n        var sourceMappingUrlRegExp = /\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)\\s*$/mg;\n        var lastSourceMappingUrl;\n        var matchSourceMappingUrl;\n        // eslint-disable-next-line no-cond-assign\n        while (matchSourceMappingUrl = sourceMappingUrlRegExp.exec(source)) {\n            lastSourceMappingUrl = matchSourceMappingUrl[1];\n        }\n        if (lastSourceMappingUrl) {\n            return lastSourceMappingUrl;\n        } else {\n            throw new Error('sourceMappingURL not found');\n        }\n    }\n\n    function _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache) {\n        return new Promise(function(resolve, reject) {\n            var loc = sourceMapConsumer.originalPositionFor({\n                line: stackframe.lineNumber,\n                column: stackframe.columnNumber\n            });\n\n            if (loc.source) {\n                // cache mapped sources\n                var mappedSource = sourceMapConsumer.sourceContentFor(loc.source);\n                if (mappedSource) {\n                    sourceCache[loc.source] = mappedSource;\n                }\n\n                resolve(\n                    // given stackframe and source location, update stackframe\n                    new StackFrame({\n                        functionName: loc.name || stackframe.functionName,\n                        args: stackframe.args,\n                        fileName: loc.source,\n                        lineNumber: loc.line,\n                        columnNumber: loc.column\n                    }));\n            } else {\n                reject(new Error('Could not get original source for given stackframe and source map'));\n            }\n        });\n    }\n\n    /**\n     * @constructor\n     * @param {Object} opts\n     *      opts.sourceCache = {url: \"Source String\"} => preload source cache\n     *      opts.sourceMapConsumerCache = {/path/file.js.map: SourceMapConsumer}\n     *      opts.offline = True to prevent network requests.\n     *              Best effort without sources or source maps.\n     *      opts.ajax = Promise returning function to make X-Domain requests\n     */\n    return function StackTraceGPS(opts) {\n        if (!(this instanceof StackTraceGPS)) {\n            return new StackTraceGPS(opts);\n        }\n        opts = opts || {};\n\n        this.sourceCache = opts.sourceCache || {};\n        this.sourceMapConsumerCache = opts.sourceMapConsumerCache || {};\n\n        this.ajax = opts.ajax || _xdr;\n\n        this._atob = opts.atob || _atob;\n\n        this._get = function _get(location) {\n            return new Promise(function(resolve, reject) {\n                var isDataUrl = location.substr(0, 5) === 'data:';\n                if (this.sourceCache[location]) {\n                    resolve(this.sourceCache[location]);\n                } else if (opts.offline && !isDataUrl) {\n                    reject(new Error('Cannot make network requests in offline mode'));\n                } else {\n                    if (isDataUrl) {\n                        // data URLs can have parameters.\n                        // see http://tools.ietf.org/html/rfc2397\n                        var supportedEncodingRegexp =\n                            /^data:application\\/json;([\\w=:\"-]+;)*base64,/;\n                        var match = location.match(supportedEncodingRegexp);\n                        if (match) {\n                            var sourceMapStart = match[0].length;\n                            var encodedSource = location.substr(sourceMapStart);\n                            var source = this._atob(encodedSource);\n                            this.sourceCache[location] = source;\n                            resolve(source);\n                        } else {\n                            reject(new Error('The encoding of the inline sourcemap is not supported'));\n                        }\n                    } else {\n                        var xhrPromise = this.ajax(location, {method: 'get'});\n                        // Cache the Promise to prevent duplicate in-flight requests\n                        this.sourceCache[location] = xhrPromise;\n                        xhrPromise.then(resolve, reject);\n                    }\n                }\n            }.bind(this));\n        };\n\n        /**\n         * Creating SourceMapConsumers is expensive, so this wraps the creation of a\n         * SourceMapConsumer in a per-instance cache.\n         *\n         * @param {String} sourceMappingURL = URL to fetch source map from\n         * @param {String} defaultSourceRoot = Default source root for source map if undefined\n         * @returns {Promise} that resolves a SourceMapConsumer\n         */\n        this._getSourceMapConsumer = function _getSourceMapConsumer(sourceMappingURL, defaultSourceRoot) {\n            return new Promise(function(resolve) {\n                if (this.sourceMapConsumerCache[sourceMappingURL]) {\n                    resolve(this.sourceMapConsumerCache[sourceMappingURL]);\n                } else {\n                    var sourceMapConsumerPromise = new Promise(function(resolve, reject) {\n                        return this._get(sourceMappingURL).then(function(sourceMapSource) {\n                            if (typeof sourceMapSource === 'string') {\n                                sourceMapSource = _parseJson(sourceMapSource.replace(/^\\)\\]\\}'/, ''));\n                            }\n                            if (typeof sourceMapSource.sourceRoot === 'undefined') {\n                                sourceMapSource.sourceRoot = defaultSourceRoot;\n                            }\n\n                            resolve(new SourceMap.SourceMapConsumer(sourceMapSource));\n                        }, reject);\n                    }.bind(this));\n                    this.sourceMapConsumerCache[sourceMappingURL] = sourceMapConsumerPromise;\n                    resolve(sourceMapConsumerPromise);\n                }\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, enhance function name and use source maps for a\n         * better StackFrame.\n         *\n         * @param {StackFrame} stackframe object\n         * @returns {Promise} that resolves with with source-mapped StackFrame\n         */\n        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {\n            return new Promise(function(resolve, reject) {\n                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {\n                    function resolveMappedStackFrame() {\n                        resolve(mappedStackFrame);\n                    }\n\n                    this.findFunctionName(mappedStackFrame)\n                        .then(resolve, resolveMappedStackFrame)\n                        // eslint-disable-next-line no-unexpected-multiline\n                        ['catch'](resolveMappedStackFrame);\n                }.bind(this), reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, guess function name from location information.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureStackFrameIsLegit(stackframe);\n                this._get(stackframe.fileName).then(function getSourceCallback(source) {\n                    var lineNumber = stackframe.lineNumber;\n                    var columnNumber = stackframe.columnNumber;\n                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);\n                    // Only replace functionName if we found something\n                    if (guessedFunctionName) {\n                        resolve(new StackFrame({\n                            functionName: guessedFunctionName,\n                            args: stackframe.args,\n                            fileName: stackframe.fileName,\n                            lineNumber: lineNumber,\n                            columnNumber: columnNumber\n                        }));\n                    } else {\n                        resolve(stackframe);\n                    }\n                }, reject)['catch'](reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureSupportedEnvironment();\n                _ensureStackFrameIsLegit(stackframe);\n\n                var sourceCache = this.sourceCache;\n                var fileName = stackframe.fileName;\n                this._get(fileName).then(function(source) {\n                    var sourceMappingURL = _findSourceMappingURL(source);\n                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';\n                    var defaultSourceRoot = fileName.substring(0, fileName.lastIndexOf('/') + 1);\n\n                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\\/\\/|^\\/\\//i).test(sourceMappingURL)) {\n                        sourceMappingURL = defaultSourceRoot + sourceMappingURL;\n                    }\n\n                    return this._getSourceMapConsumer(sourceMappingURL, defaultSourceRoot)\n                        .then(function(sourceMapConsumer) {\n                            return _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache)\n                                .then(resolve)['catch'](function() {\n                                    resolve(stackframe);\n                                });\n                        });\n                }.bind(this), reject)['catch'](reject);\n            }.bind(this));\n        };\n    };\n}));\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require(144);\nvar binarySearch = require(141);\nvar ArraySet = require(138).ArraySet;\nvar base64VLQ = require(139);\nvar quickSort = require(142).quickSort;\n\nfunction SourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap)\n    : new BasicSourceMapConsumer(sourceMap);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      if (source != null && sourceRoot != null) {\n        source = util.join(sourceRoot, source);\n      }\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: Optional. the column number in the original source.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    if (this.sourceRoot != null) {\n      needle.source = util.relative(this.sourceRoot, needle.source);\n    }\n    if (!this._sources.has(needle.source)) {\n      return [];\n    }\n    needle.source = this._sources.indexOf(needle.source);\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The only parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._sources.toArray().map(function (s) {\n      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n    }, this);\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          if (this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    if (this.sourceRoot != null) {\n      aSource = util.relative(this.sourceRoot, aSource);\n    }\n\n    if (this._sources.has(aSource)) {\n      return this.sourcesContent[this._sources.indexOf(aSource)];\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + aSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    if (this.sourceRoot != null) {\n      source = util.relative(this.sourceRoot, source);\n    }\n    if (!this._sources.has(source)) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n    source = this._sources.indexOf(source);\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The only parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        if (section.consumer.sourceRoot !== null) {\n          source = util.join(section.consumer.sourceRoot, source);\n        }\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = section.consumer._names.at(mapping.name);\n        this._names.add(name);\n        name = this._names.indexOf(name);\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require(140);\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require(144);\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = util.toSetString(aStr);\n  var isDuplicate = has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    this._set[sStr] = idx;\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  var sStr = util.toSetString(aStr);\n  return has.call(this._set, sStr);\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  var sStr = util.toSetString(aStr);\n  if (has.call(this._set, sStr)) {\n    return this._set[sStr];\n  }\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stack-generator', ['stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require(137));\n    } else {\n        root.StackGenerator = factory(root.StackFrame);\n    }\n}(this, function(StackFrame) {\n    return {\n        backtrace: function StackGenerator$$backtrace(opts) {\n            var stack = [];\n            var maxStackSize = 10;\n\n            if (typeof opts === 'object' && typeof opts.maxStackSize === 'number') {\n                maxStackSize = opts.maxStackSize;\n            }\n\n            var curr = arguments.callee;\n            while (curr && stack.length < maxStackSize && curr['arguments']) {\n                // Allow V8 optimizations\n                var args = new Array(curr['arguments'].length);\n                for (var i = 0; i < args.length; ++i) {\n                    args[i] = curr['arguments'][i];\n                }\n                if (/function(?:\\s+([\\w$]+))+\\s*\\(/.test(curr.toString())) {\n                    stack.push(new StackFrame({functionName: RegExp.$1 || undefined, args: args}));\n                } else {\n                    stack.push(new StackFrame({args: args}));\n                }\n\n                try {\n                    curr = curr.caller;\n                } catch (e) {\n                    break;\n                }\n            }\n            return stack;\n        }\n    };\n}));\n","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('error-stack-parser', ['stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require(137));\n    } else {\n        root.ErrorStackParser = factory(root.StackFrame);\n    }\n}(this, function ErrorStackParser(StackFrame) {\n    'use strict';\n\n    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\n    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\n    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\n\n    return {\n        /**\n         * Given an Error object, extract the most information from it.\n         *\n         * @param {Error} error object\n         * @return {Array} of StackFrames\n         */\n        parse: function ErrorStackParser$$parse(error) {\n            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n                return this.parseOpera(error);\n            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n                return this.parseV8OrIE(error);\n            } else if (error.stack) {\n                return this.parseFFOrSafari(error);\n            } else {\n                throw new Error('Cannot parse given Error object');\n            }\n        },\n\n        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n            // Fail-fast but return locations like \"(native)\"\n            if (urlLike.indexOf(':') === -1) {\n                return [urlLike];\n            }\n\n            var regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n            var parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n            return [parts[1], parts[2] || undefined, parts[3] || undefined];\n        },\n\n        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n            var filtered = error.stack.split('\\n').filter(function(line) {\n                return !!line.match(CHROME_IE_STACK_REGEXP);\n            }, this);\n\n            return filtered.map(function(line) {\n                if (line.indexOf('(eval ') > -1) {\n                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n                    line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n                }\n                var sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(');\n\n                // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n                // case it has spaces in it, as the string is split on \\s+ later on\n                var location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n\n                // remove the parenthesized location from the line, if it was matched\n                sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;\n\n                var tokens = sanitizedLine.split(/\\s+/).slice(1);\n                // if a location was matched, pass it to extractLocation() otherwise pop the last token\n                var locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n                var functionName = tokens.join(' ') || undefined;\n                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n\n                return new StackFrame({\n                    functionName: functionName,\n                    fileName: fileName,\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2],\n                    source: line\n                });\n            }, this);\n        },\n\n        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n            var filtered = error.stack.split('\\n').filter(function(line) {\n                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n            }, this);\n\n            return filtered.map(function(line) {\n                // Throw away eval information until we implement stacktrace.js/stackframe#8\n                if (line.indexOf(' > eval') > -1) {\n                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, ':$1');\n                }\n\n                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n                    // Safari eval frames only have function names and nothing else\n                    return new StackFrame({\n                        functionName: line\n                    });\n                } else {\n                    var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n                    var matches = line.match(functionNameRegex);\n                    var functionName = matches && matches[1] ? matches[1] : undefined;\n                    var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));\n\n                    return new StackFrame({\n                        functionName: functionName,\n                        fileName: locationParts[0],\n                        lineNumber: locationParts[1],\n                        columnNumber: locationParts[2],\n                        source: line\n                    });\n                }\n            }, this);\n        },\n\n        parseOpera: function ErrorStackParser$$parseOpera(e) {\n            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n                return this.parseOpera9(e);\n            } else if (!e.stack) {\n                return this.parseOpera10(e);\n            } else {\n                return this.parseOpera11(e);\n            }\n        },\n\n        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n            var lines = e.message.split('\\n');\n            var result = [];\n\n            for (var i = 2, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame({\n                        fileName: match[2],\n                        lineNumber: match[1],\n                        source: lines[i]\n                    }));\n                }\n            }\n\n            return result;\n        },\n\n        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n            var lines = e.stacktrace.split('\\n');\n            var result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(\n                        new StackFrame({\n                            functionName: match[3] || undefined,\n                            fileName: match[2],\n                            lineNumber: match[1],\n                            source: lines[i]\n                        })\n                    );\n                }\n            }\n\n            return result;\n        },\n\n        // Opera 10.65+ Error.stack very similar to FF/Safari\n        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n            var filtered = error.stack.split('\\n').filter(function(line) {\n                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n            }, this);\n\n            return filtered.map(function(line) {\n                var tokens = line.split('@');\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionCall = (tokens.shift() || '');\n                var functionName = functionCall\n                    .replace(/<anonymous function(: (\\w+))?>/, '$2')\n                    .replace(/\\([^)]*\\)/g, '') || undefined;\n                var argsRaw;\n                if (functionCall.match(/\\(([^)]*)\\)/)) {\n                    argsRaw = functionCall.replace(/^[^(]+\\(([^)]*)\\)$/, '$1');\n                }\n                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?\n                    undefined : argsRaw.split(',');\n\n                return new StackFrame({\n                    functionName: functionName,\n                    args: args,\n                    fileName: locationParts[0],\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2],\n                    source: line\n                });\n            }, this);\n        }\n    };\n}));\n","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stackframe', [], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.StackFrame = factory();\n    }\n}(this, function() {\n    'use strict';\n    function _isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    function _capitalize(str) {\n        return str.charAt(0).toUpperCase() + str.substring(1);\n    }\n\n    function _getter(p) {\n        return function() {\n            return this[p];\n        };\n    }\n\n    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n    var numericProps = ['columnNumber', 'lineNumber'];\n    var stringProps = ['fileName', 'functionName', 'source'];\n    var arrayProps = ['args'];\n    var objectProps = ['evalOrigin'];\n\n    var props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);\n\n    function StackFrame(obj) {\n        if (!obj) return;\n        for (var i = 0; i < props.length; i++) {\n            if (obj[props[i]] !== undefined) {\n                this['set' + _capitalize(props[i])](obj[props[i]]);\n            }\n        }\n    }\n\n    StackFrame.prototype = {\n        getArgs: function() {\n            return this.args;\n        },\n        setArgs: function(v) {\n            if (Object.prototype.toString.call(v) !== '[object Array]') {\n                throw new TypeError('Args must be an Array');\n            }\n            this.args = v;\n        },\n\n        getEvalOrigin: function() {\n            return this.evalOrigin;\n        },\n        setEvalOrigin: function(v) {\n            if (v instanceof StackFrame) {\n                this.evalOrigin = v;\n            } else if (v instanceof Object) {\n                this.evalOrigin = new StackFrame(v);\n            } else {\n                throw new TypeError('Eval Origin must be an Object or StackFrame');\n            }\n        },\n\n        toString: function() {\n            var fileName = this.getFileName() || '';\n            var lineNumber = this.getLineNumber() || '';\n            var columnNumber = this.getColumnNumber() || '';\n            var functionName = this.getFunctionName() || '';\n            if (this.getIsEval()) {\n                if (fileName) {\n                    return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n                }\n                return '[eval]:' + lineNumber + ':' + columnNumber;\n            }\n            if (functionName) {\n                return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n            }\n            return fileName + ':' + lineNumber + ':' + columnNumber;\n        }\n    };\n\n    StackFrame.fromString = function StackFrame$$fromString(str) {\n        var argsStartIndex = str.indexOf('(');\n        var argsEndIndex = str.lastIndexOf(')');\n\n        var functionName = str.substring(0, argsStartIndex);\n        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');\n        var locationString = str.substring(argsEndIndex + 1);\n\n        if (locationString.indexOf('@') === 0) {\n            var parts = /@(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(locationString, '');\n            var fileName = parts[1];\n            var lineNumber = parts[2];\n            var columnNumber = parts[3];\n        }\n\n        return new StackFrame({\n            functionName: functionName,\n            args: args || undefined,\n            fileName: fileName,\n            lineNumber: lineNumber || undefined,\n            columnNumber: columnNumber || undefined\n        });\n    };\n\n    for (var i = 0; i < booleanProps.length; i++) {\n        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {\n            return function(v) {\n                this[p] = Boolean(v);\n            };\n        })(booleanProps[i]);\n    }\n\n    for (var j = 0; j < numericProps.length; j++) {\n        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {\n            return function(v) {\n                if (!_isNumber(v)) {\n                    throw new TypeError(p + ' must be a Number');\n                }\n                this[p] = Number(v);\n            };\n        })(numericProps[j]);\n    }\n\n    for (var k = 0; k < stringProps.length; k++) {\n        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {\n            return function(v) {\n                this[p] = String(v);\n            };\n        })(stringProps[k]);\n    }\n\n    return StackFrame;\n}));\n","const ErrorToString = Error.prototype.toString;\n\nfunction prepareStackTrace(err, trace) {\n  const errorString = ErrorToString.call(err);\n  if (trace.length === 0) return errorString;\n\n  return `${errorString}\\n    at ${trace.join('\\n    at ')}`;\n}\n\nmodule.exports = prepareStackTrace;\n"]}